# Mise configuration for Codex Linux AppImage workflow

[tools]
node = "22"
jq = "latest"

[env]
WORKDIR = "{{env.HOME}}/.cache/codex-linux-port"
CODEX_DMG_URL = "https://persistent.oaistatic.com/codex-app-prod/Codex.dmg"
ENABLE_LINUX_UI_POLISH = "1"
CODEX_GIT_REF = "rust-v0.102.0-alpha.5"

[tasks."codex:vm:check"]
description = "Run remote VM preflight checks"
run = "bash infra/vm/codex-vm check"

[tasks."codex:vm:linux:build"]
description = "Build Codex AppImage on remote Linux VM"
run = "bash infra/vm/codex-vm linux"

[tasks."codex:vm:win:build"]
description = "Build Windows installer on remote Windows VM"
run = "bash infra/vm/codex-vm win"

[tasks."codex:vm:build"]
description = "Build Linux and Windows artifacts via remote VM orchestrator"
run = "bash infra/vm/codex-vm both"

[tasks."codex:vm:release"]
description = "Run remote VM build and keep artifacts locally"
run = "bash infra/vm/codex-vm release"

[tasks."codex:docker-build"]
description = "Build codex-builder Docker image"
run = "docker build -t codex-builder {{config_root}}"

[tasks."codex:docker-run"]
description = "Run extraction and Rust build in container"
depends = ["codex:docker-build"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output"
rm -rf "$docker_output_dir"
mkdir -p "$docker_output_dir"

if [ -f "{{config_root}}/ui-design-overrides.json" ]; then
  cp "{{config_root}}/ui-design-overrides.json" "$docker_output_dir/ui-design-overrides.json"
fi

docker run --rm \
  --entrypoint bash \
  --cap-add SYS_ADMIN \
  --security-opt apparmor:unconfined \
  -e WORKDIR=/output/work \
  -e CODEX_DMG_URL="{{env.CODEX_DMG_URL}}" \
  -e ENABLE_LINUX_UI_POLISH="{{env.ENABLE_LINUX_UI_POLISH}}" \
  -e CODEX_GIT_REF="{{env.CODEX_GIT_REF}}" \
  -e UI_OVERRIDES_FILE=/output/ui-design-overrides.json \
  -v "$docker_output_dir:/output" \
  codex-builder -c '
set -euo pipefail
mkdir -p "$WORKDIR"
cd "$WORKDIR"

if [ ! -f Codex.dmg ]; then
  if command -v curl >/dev/null 2>&1; then
    curl -L --fail --output Codex.dmg "$CODEX_DMG_URL"
  else
    wget -O Codex.dmg "$CODEX_DMG_URL"
  fi
fi

rm -f Codex.img
dmg2img Codex.dmg Codex.img

rm -rf extracted app_unpacked
mkdir -p extracted
7z x Codex.img -oextracted/ -y >/dev/null || true

ASAR_PATH=$(find extracted -name app.asar -type f | head -1)
if [ -z "$ASAR_PATH" ]; then
  echo "Could not locate app.asar" >&2
  exit 1
fi

NODE_MAJOR=$(node -v | sed -E "s/^v([0-9]+).*/\\1/")
ASAR_PKG="@electron/asar"
if [ "$NODE_MAJOR" -lt 22 ]; then
  ASAR_PKG="@electron/asar@3.2.13"
fi

mkdir -p .npm-local
npm init -y --prefix .npm-local >/dev/null 2>&1 || true
npm install --prefix .npm-local "$ASAR_PKG" >/dev/null
.npm-local/node_modules/.bin/asar extract "$ASAR_PATH" app_unpacked/

rm -rf codex-src
git clone https://github.com/openai/codex.git codex-src >/dev/null

cd codex-src
if [ "$CODEX_GIT_REF" = "latest-tag" ]; then
  git fetch --tags --force >/dev/null 2>&1 || true
  SELECTED_TAG=""
  for tag in $(git tag --sort=-v:refname | head -n 200); do
    git checkout --detach "$tag" >/dev/null 2>&1 || continue
    if cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
      SELECTED_TAG="$tag"
      break
    fi
  done
  if [ -z "$SELECTED_TAG" ]; then
    git checkout --detach HEAD >/dev/null 2>&1
    cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1 || {
      echo "No buildable codex ref found" >&2
      exit 1
    }
  fi
else
  git fetch --depth 1 origin "$CODEX_GIT_REF" >/dev/null
  git checkout --detach FETCH_HEAD >/dev/null
  if ! cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
    echo "Selected ref $CODEX_GIT_REF is not buildable" >&2
    cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps
    exit 1
  fi
fi

cd codex-rs
cargo build --release --bin codex
cargo build --release --bin codex-linux-sandbox || true

cd "$WORKDIR/app_unpacked"
rm -f native/sparkle.node
rm -rf node_modules/electron-liquid-glass

mkdir -p resources resources/bin
cp "$WORKDIR/codex-src/codex-rs/target/release/codex" resources/codex
chmod +x resources/codex
cp resources/codex resources/bin/codex
chmod +x resources/bin/codex

if [ -f "$WORKDIR/codex-src/codex-rs/target/release/codex-linux-sandbox" ]; then
  cp "$WORKDIR/codex-src/codex-rs/target/release/codex-linux-sandbox" resources/
  chmod +x resources/codex-linux-sandbox
fi

if [ "$ENABLE_LINUX_UI_POLISH" = "1" ]; then
  css_file=$(ls webview/assets/index-*.css 2>/dev/null | head -1 || true)
  if [ -n "$css_file" ]; then
    CSS_FILE="$css_file" node - <<"NODE"
const fs = require("fs");

const cssFile = process.env.CSS_FILE;
const css = fs.readFileSync(cssFile, "utf8");
const overridePath = process.env.UI_OVERRIDES_FILE || "";

let manualTokenOverrides = {};
let manualTitlebarTint = "";
if (overridePath && fs.existsSync(overridePath)) {
  try {
    const parsed = JSON.parse(fs.readFileSync(overridePath, "utf8"));
    if (parsed && typeof parsed === "object") {
      if (parsed.token_overrides && typeof parsed.token_overrides === "object") {
        manualTokenOverrides = parsed.token_overrides;
      }
      if (typeof parsed.codex_titlebar_tint === "string" && parsed.codex_titlebar_tint.trim()) {
        manualTitlebarTint = parsed.codex_titlebar_tint.trim();
      }
    }
  } catch {
    manualTokenOverrides = {};
    manualTitlebarTint = "";
  }
}

function readThemeVar(selector, key) {
  const token = selector + "{";
  let pos = 0;
  while (true) {
    const start = css.indexOf(token, pos);
    if (start === -1) return "";
    let i = start + token.length;
    let depth = 1;
    while (i < css.length && depth > 0) {
      const ch = css[i];
      if (ch === "{") depth += 1;
      else if (ch === "}") depth -= 1;
      i += 1;
    }
    const block = css.slice(start + token.length, i - 1);
    for (const decl of block.split(";")) {
      const idx = decl.indexOf(":");
      if (idx === -1) continue;
      const declKey = decl.slice(0, idx).trim();
      const value = decl.slice(idx + 1).trim();
      if (declKey === key) return value;
    }
    pos = i;
  }
}

const semanticDefaults = {
  "--color-background-surface": readThemeVar(".electron-light", "--color-background-surface") || "var(--gray-0)",
  "--color-background-surface-under": readThemeVar(".electron-light", "--color-background-surface-under") || "var(--gray-0)",
  "--color-background-elevated-primary": readThemeVar(".electron-light", "--color-background-elevated-primary") || "color-mix(in oklab, var(--gray-0) 88%, transparent)",
  "--color-background-elevated-secondary": readThemeVar(".electron-light", "--color-background-elevated-secondary") || "color-mix(in oklab, var(--gray-1000) 2%, transparent)",
  "--color-border": readThemeVar(".electron-light", "--color-border") || "color-mix(in oklab, var(--gray-1000) 8%, transparent)",
  "--color-text-foreground": readThemeVar(".electron-light", "--color-text-foreground") || "var(--gray-1000)",
  "--color-text-foreground-secondary": readThemeVar(".electron-light", "--color-text-foreground-secondary") || "color-mix(in oklab, var(--gray-1000) 70%, transparent)",
  "--color-icon-primary": readThemeVar(".electron-light", "--color-icon-primary") || "var(--gray-1000)",
};

const lines = [];
lines.push("/* Auto-generated Linux polish: conservative semantic overrides */");
lines.push(".electron-light,");
lines.push(".electron-dark {");
lines.push("  color-scheme: light;");
for (const [key, value] of Object.entries(semanticDefaults)) {
  lines.push(`  ${key}: ${value};`);
}
for (const [key, value] of Object.entries(manualTokenOverrides)) {
  if (typeof key !== "string" || typeof value !== "string") continue;
  if (!key.startsWith("--")) continue;
  lines.push(`  ${key}: ${value};`);
}
const titlebarTint = manualTitlebarTint || "color-mix(in oklab, var(--blue-100) 42%, transparent)";
lines.push(`  --codex-titlebar-tint: ${titlebarTint};`);
lines.push("}");
lines.push("");
lines.push("/* Keep structure untouched; token-only overrides for stability */");
lines.push(".electron-light aside,");
lines.push(".electron-dark aside,");
lines.push(`.electron-light [role="navigation"],`);
lines.push(`.electron-dark [role="navigation"] {`);
lines.push("  box-shadow: none !important;");
lines.push("  background-color: var(--color-background-surface) !important;");
lines.push("  opacity: 1 !important;");
lines.push("  filter: none !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light nav[role=\\\"navigation\\\"],");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] {");
lines.push("  mask-image: none !important;");
lines.push("  -webkit-mask-image: none !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light nav[role=\\\"navigation\\\"] button.opacity-75:not(:disabled),");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] button.opacity-75:not(:disabled),");
lines.push(".electron-light nav[role=\\\"navigation\\\"] [role=\\\"button\\\"].opacity-75:not([aria-disabled=\\\"true\\\"]),");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] [role=\\\"button\\\"].opacity-75:not([aria-disabled=\\\"true\\\"]) {");
lines.push("  opacity: 1 !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light nav[role=\\\"navigation\\\"] [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-light aside [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-dark aside [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground {");
lines.push("  opacity: 1 !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light aside .text-token-description-foreground,");
lines.push(".electron-dark aside .text-token-description-foreground,");
lines.push(".electron-light aside .text-token-input-placeholder-foreground,");
lines.push(".electron-dark aside .text-token-input-placeholder-foreground,");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground {");
lines.push("  color: var(--color-text-foreground-secondary) !important;");
lines.push("  opacity: 1 !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light .app-header-tint,");
lines.push(".electron-dark .app-header-tint {");
lines.push("  box-shadow: none !important;");
lines.push("}");
lines.push("");
lines.push("/* Hide debug-only navigation entries in production builds */");
lines.push("nav[role=\\\"navigation\\\"] [aria-label=\\\"Debug\\\"],");
lines.push("nav[role=\\\"navigation\\\"] [title=\\\"Debug\\\"],");
lines.push("nav[role=\\\"navigation\\\"] a[href$=\\\"/debug\\\"],");
lines.push("nav[role=\\\"navigation\\\"] a[href*=\\\"/debug?\\\"],");
lines.push("aside [aria-label=\\\"Debug\\\"],");
lines.push("aside [title=\\\"Debug\\\"],");
lines.push("aside a[href$=\\\"/debug\\\"],");
lines.push("aside a[href*=\\\"/debug?\\\"] {");
lines.push("  display: none !important;");
lines.push("}");

const nl = String.fromCharCode(10);
fs.writeFileSync("webview/assets/linux-polish.css", lines.join(nl) + nl, "utf8");
console.log("generated linux-polish.css with conservative semantic overrides");
NODE
  fi

  node - <<"NODE"
const fs = require("fs");
const file = "webview/index.html";
let html = fs.readFileSync(file, "utf8");
const nl = String.fromCharCode(10);

html = html
  .split(nl)
  .filter((line) => !line.includes("linux-polish.css"))
  .join(nl);

if (!html.includes("linux-polish.css")) {
  html = html.replace("</head>", `    <link rel="stylesheet" href="./assets/linux-polish.css">` + nl + "</head>");
}

fs.writeFileSync(file, html, "utf8");
NODE
fi

cat > codex-linux.sh <<"LAUNCHER"
#!/bin/sh
APP_DIR="$(cd "$(dirname "$0")" && pwd)"
export PATH="${APP_DIR}/resources:${APP_DIR}/resources/bin:${PATH}"
export CODEX_CLI_PATH="${APP_DIR}/resources/bin/codex"

if [ ! -f "${CODEX_CLI_PATH}" ]; then
  echo "codex binary not found at ${CODEX_CLI_PATH}" >&2
  exit 1
fi

if command -v electron >/dev/null 2>&1; then
  exec electron "${APP_DIR}" "$@"
fi

echo "Electron not installed. Run CLI: ${CODEX_CLI_PATH}" >&2
exit 1
LAUNCHER
chmod +x codex-linux.sh
'
"""

[tasks."codex:prepare-bundle"]
description = "Copy built bundle to stable cache path"
depends = ["codex:docker-run"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output"
bundle_dir="$docker_output_dir/codex-linux"

if [ -d "$docker_output_dir/work/app_unpacked" ]; then
  rm -rf "$bundle_dir"
  cp -a "$docker_output_dir/work/app_unpacked" "$bundle_dir"
fi

if [ ! -d "$bundle_dir" ]; then
  echo "âŒ Missing app bundle after Docker build" >&2
  exit 1
fi
"""

[tasks."codex:rebuild-native"]
description = "Rebuild native modules against host Electron ABI"
depends = ["codex:prepare-bundle"]
run = """
set -euo pipefail
app_dir="{{env.WORKDIR}}/docker-output/codex-linux"
native_build_dir="{{env.WORKDIR}}/native-build-host"

if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
  echo "âŒ node and npm are required on host for native module rebuild" >&2
  exit 1
fi

pushd "$app_dir" >/dev/null
package_electron_version=$(node -p "require('./package.json').devDependencies?.electron || ''" 2>/dev/null || true)
package_electron_version="${package_electron_version#^}"

host_electron_version=""
if command -v electron >/dev/null 2>&1; then
  host_electron_version=$(electron --version 2>/dev/null || true)
  host_electron_version="${host_electron_version#v}"
  host_electron_version="${host_electron_version#^}"
fi

electron_version="${host_electron_version:-${package_electron_version}}"
if [ -z "$electron_version" ]; then
  echo "âŒ Unable to determine Electron version for native rebuild" >&2
  exit 1
fi

sqlite_version=$(node -p "require('./node_modules/better-sqlite3/package.json').version" 2>/dev/null || echo "12.5.0")
pty_version=$(node -p "require('./node_modules/node-pty/package.json').version" 2>/dev/null || echo "1.1.0")
popd >/dev/null

rm -rf "$native_build_dir"
mkdir -p "$native_build_dir"
pushd "$native_build_dir" >/dev/null
npm init -y >/dev/null 2>&1

npm_config_runtime=electron \
npm_config_target="$electron_version" \
npm_config_disturl=https://electronjs.org/headers \
npm install --force --no-save "better-sqlite3@${sqlite_version}" "node-pty@${pty_version}" >/dev/null

popd >/dev/null

mkdir -p "$app_dir/node_modules/better-sqlite3/build/Release"
mkdir -p "$app_dir/node_modules/node-pty/build/Release"
cp -f "$native_build_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node" "$app_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node"
cp -f "$native_build_dir/node_modules/node-pty/build/Release/pty.node" "$app_dir/node_modules/node-pty/build/Release/pty.node"

file "$app_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node" | grep -q ELF
file "$app_dir/node_modules/node-pty/build/Release/pty.node" | grep -q ELF

if ldd "$app_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node" | grep -q libnode; then
  echo "âŒ better-sqlite3 still links libnode" >&2
  exit 1
fi

if ldd "$app_dir/node_modules/node-pty/build/Release/pty.node" | grep -q libnode; then
  echo "âŒ node-pty still links libnode" >&2
  exit 1
fi
"""

[tasks."codex:package-appimage"]
description = "Package Codex.AppImage into repo root"
depends = ["codex:rebuild-native"]
run = """
set -euo pipefail
bundle_dir="{{env.WORKDIR}}/docker-output/codex-linux"
output_path="{{config_root}}/Codex.AppImage"

if [ ! -d "$bundle_dir" ]; then
  echo "âŒ App bundle not found at $bundle_dir" >&2
  exit 1
fi

tempdir=$(mktemp -d)
appdir="$tempdir/Codex.AppDir"
mkdir -p "$appdir/usr/share/codex" "$appdir/usr/bin"

cp -a "$bundle_dir"/. "$appdir/usr/share/codex/"
cp -f "$appdir/usr/share/codex/resources/bin/codex" "$appdir/usr/bin/codex"
chmod +x "$appdir/usr/bin/codex"

cat > "$appdir/AppRun" <<"EOF"
#!/bin/sh
HERE="$(dirname "$(readlink -f "$0")")"
APP_DIR="${HERE}/usr/share/codex"
export PATH="${APP_DIR}/resources:${APP_DIR}/resources/bin:${PATH}"
export CODEX_CLI_PATH="${APP_DIR}/resources/bin/codex"

if [ "${1:-}" = "--cli" ]; then
  shift
  exec "${CODEX_CLI_PATH}" "$@"
fi

if command -v electron >/dev/null 2>&1; then
  exec electron "${APP_DIR}" "$@"
fi

echo "Electron not found on host."
echo "Run CLI mode with: ./Codex.AppImage --cli --help"
exit 1
EOF
chmod +x "$appdir/AppRun"

cat > "$appdir/codex.desktop" <<"EOF"
[Desktop Entry]
Name=Codex
GenericName=AI Coding Assistant
Comment=OpenAI Codex - AI-powered coding assistant
Exec=AppRun
Icon=codex
Terminal=false
Type=Application
Categories=Development;IDE;TextEditor;
Keywords=codex;ai;code;editor;openai;
EOF

icon_src=$(ls "$appdir"/usr/share/codex/webview/assets/app-*.png 2>/dev/null | head -1 || true)
if [ -z "$icon_src" ]; then
  icon_src=$(ls "$appdir"/usr/share/codex/webview/assets/logo-*.png 2>/dev/null | head -1 || true)
fi
if [ -z "$icon_src" ]; then
  echo "âŒ Could not find Codex icon PNG in bundle" >&2
  exit 1
fi
cp -f "$icon_src" "$appdir/codex.png"

tools_dir="{{env.WORKDIR}}/tools"
appimagetool="$tools_dir/appimagetool.AppImage"
mkdir -p "$tools_dir"

if [ ! -x "$appimagetool" ]; then
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL -o "$appimagetool" "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
  else
    wget -qO "$appimagetool" "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
  fi
  chmod +x "$appimagetool"
fi

rm -f "$output_path"
ARCH=x86_64 APPIMAGE_EXTRACT_AND_RUN=1 "$appimagetool" "$appdir" "$output_path" >/dev/null
chmod +x "$output_path"
rm -rf "$tempdir"
"""

[tasks."codex:versions"]
description = "Update versions.json from generated AppImage"
depends = ["codex:package-appimage"]
run = """
set -euo pipefail
appimage_path="{{config_root}}/Codex.AppImage"
versions_file="{{config_root}}/versions.json"

if [ ! -x "$appimage_path" ]; then
  echo "âŒ AppImage not found at $appimage_path" >&2
  exit 1
fi

cli_version_output="$($appimage_path --cli --version)"
cli_version="$(awk '{print $2}' <<<"$cli_version_output")"
if [ -z "$cli_version" ]; then
  echo "âŒ Failed to parse CLI version" >&2
  exit 1
fi

tmp=$(mktemp -d)
cp "$appimage_path" "$tmp/Codex.AppImage"
(cd "$tmp" && ./Codex.AppImage --appimage-extract >/dev/null 2>&1)
app_version="$(node -p "require('$tmp/squashfs-root/usr/share/codex/package.json').version" 2>/dev/null || true)"
rm -rf "$tmp"

if [ -z "$app_version" ]; then
  echo "âŒ Failed to parse app version" >&2
  exit 1
fi

cat > "$versions_file" <<EOF
{
  "app": "$app_version",
  "cli": "$cli_version"
}
EOF
"""

[tasks."codex:ui:extract"]
description = "Extract current AppImage assets for UI analysis"
run = """
set -euo pipefail
appimage_path="{{config_root}}/Codex.AppImage"
inspect_dir="{{config_root}}/.ui-inspect"

if [ ! -x "$appimage_path" ]; then
  echo "âŒ AppImage not found at $appimage_path (run: mise run codex:build)" >&2
  exit 1
fi

rm -rf "$inspect_dir"
mkdir -p "$inspect_dir"
cp "$appimage_path" "$inspect_dir/Codex.AppImage"
(cd "$inspect_dir" && ./Codex.AppImage --appimage-extract >/dev/null 2>&1)

css_file=$(ls "$inspect_dir"/squashfs-root/usr/share/codex/webview/assets/index-*.css 2>/dev/null | head -1 || true)
if [ -z "$css_file" ]; then
  echo "âŒ Could not locate bundled index CSS in extracted AppImage" >&2
  exit 1
fi

cp "$css_file" "$inspect_dir/index.css"
if [ -f "$inspect_dir/squashfs-root/usr/share/codex/webview/assets/linux-polish.css" ]; then
  cp "$inspect_dir/squashfs-root/usr/share/codex/webview/assets/linux-polish.css" "$inspect_dir/linux-polish.css"
fi

echo "UI inspect assets ready at: $inspect_dir"
"""

[tasks."codex:ui:sync-polish"]
description = "Regenerate linux-polish.css in extracted UI bundle"
run = """
set -euo pipefail
inspect_dir="{{config_root}}/.ui-inspect"
assets_dir="$inspect_dir/squashfs-root/usr/share/codex/webview/assets"
index_html="$inspect_dir/squashfs-root/usr/share/codex/webview/index.html"
candidate_file="{{config_root}}/ui-design-overrides.candidate.json"
pinned_file="{{config_root}}/ui-design-overrides.json"

if [ ! -d "$assets_dir" ]; then
  mise run codex:ui:extract >/dev/null
fi

css_file=$(ls "$assets_dir"/index-*.css 2>/dev/null | head -1 || true)
if [ -z "$css_file" ]; then
  echo "âŒ Could not locate bundled index CSS in extracted AppImage" >&2
  exit 1
fi

override_file="${UI_OVERRIDES_FILE:-}"
if [ -z "$override_file" ]; then
  if [ -s "$candidate_file" ]; then
    override_file="$candidate_file"
  elif [ -s "$pinned_file" ]; then
    override_file="$pinned_file"
  fi
fi

CSS_FILE="$css_file" OVERRIDE_FILE="$override_file" OUT_FILE="$assets_dir/linux-polish.css" node - <<'NODE'
const fs = require('fs');

const cssFile = process.env.CSS_FILE;
const overridePath = process.env.OVERRIDE_FILE || '';
const outFile = process.env.OUT_FILE;
const css = fs.readFileSync(cssFile, 'utf8');

let manualTokenOverrides = {};
let manualTitlebarTint = '';
if (overridePath && fs.existsSync(overridePath)) {
  try {
    const parsed = JSON.parse(fs.readFileSync(overridePath, 'utf8'));
    if (parsed && typeof parsed === 'object') {
      if (parsed.token_overrides && typeof parsed.token_overrides === 'object') {
        manualTokenOverrides = parsed.token_overrides;
      }
      if (typeof parsed.codex_titlebar_tint === 'string' && parsed.codex_titlebar_tint.trim()) {
        manualTitlebarTint = parsed.codex_titlebar_tint.trim();
      }
    }
  } catch {
    manualTokenOverrides = {};
    manualTitlebarTint = '';
  }
}

function readThemeVar(selector, key) {
  const token = selector + '{';
  let pos = 0;
  while (true) {
    const start = css.indexOf(token, pos);
    if (start === -1) return '';
    let i = start + token.length;
    let depth = 1;
    while (i < css.length && depth > 0) {
      const ch = css[i];
      if (ch === '{') depth += 1;
      else if (ch === '}') depth -= 1;
      i += 1;
    }
    const block = css.slice(start + token.length, i - 1);
    for (const decl of block.split(';')) {
      const idx = decl.indexOf(':');
      if (idx === -1) continue;
      const declKey = decl.slice(0, idx).trim();
      const value = decl.slice(idx + 1).trim();
      if (declKey === key) return value;
    }
    pos = i;
  }
}

const semanticDefaults = {
  '--color-background-surface': readThemeVar('.electron-light', '--color-background-surface') || 'var(--gray-0)',
  '--color-background-surface-under': readThemeVar('.electron-light', '--color-background-surface-under') || 'var(--gray-0)',
  '--color-background-elevated-primary': readThemeVar('.electron-light', '--color-background-elevated-primary') || 'color-mix(in oklab, var(--gray-0) 88%, transparent)',
  '--color-background-elevated-secondary': readThemeVar('.electron-light', '--color-background-elevated-secondary') || 'color-mix(in oklab, var(--gray-1000) 2%, transparent)',
  '--color-border': readThemeVar('.electron-light', '--color-border') || 'color-mix(in oklab, var(--gray-1000) 8%, transparent)',
  '--color-text-foreground': readThemeVar('.electron-light', '--color-text-foreground') || 'var(--gray-1000)',
  '--color-text-foreground-secondary': readThemeVar('.electron-light', '--color-text-foreground-secondary') || 'color-mix(in oklab, var(--gray-1000) 70%, transparent)',
  '--color-icon-primary': readThemeVar('.electron-light', '--color-icon-primary') || 'var(--gray-1000)',
};

const lines = [];
lines.push('/* Auto-generated Linux polish: conservative semantic overrides */');
lines.push('.electron-light,');
lines.push('.electron-dark {');
lines.push('  color-scheme: light;');
for (const [key, value] of Object.entries(semanticDefaults)) {
  lines.push(`  ${key}: ${value};`);
}
for (const [key, value] of Object.entries(manualTokenOverrides)) {
  if (typeof key !== 'string' || typeof value !== 'string') continue;
  if (!key.startsWith('--')) continue;
  lines.push(`  ${key}: ${value};`);
}
const titlebarTint = manualTitlebarTint || 'color-mix(in oklab, var(--blue-100) 42%, transparent)';
lines.push(`  --codex-titlebar-tint: ${titlebarTint};`);
lines.push('}');
lines.push('');
lines.push('/* Keep structure untouched; token-only overrides for stability */');
lines.push('.electron-light aside,');
lines.push('.electron-dark aside,');
lines.push('.electron-light [role="navigation"],');
lines.push('.electron-dark [role="navigation"] {');
lines.push('  box-shadow: none !important;');
lines.push('  background-color: var(--color-background-surface) !important;');
lines.push('  opacity: 1 !important;');
lines.push('  filter: none !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light nav[role="navigation"],');
lines.push('.electron-dark nav[role="navigation"] {');
lines.push('  mask-image: none !important;');
lines.push('  -webkit-mask-image: none !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light nav[role="navigation"] button.opacity-75:not(:disabled),');
lines.push('.electron-dark nav[role="navigation"] button.opacity-75:not(:disabled),');
lines.push('.electron-light nav[role="navigation"] [role="button"].opacity-75:not([aria-disabled="true"]),');
lines.push('.electron-dark nav[role="navigation"] [role="button"].opacity-75:not([aria-disabled="true"]) {');
lines.push('  opacity: 1 !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light nav[role="navigation"] [class*="electron:opacity-75"],');
lines.push('.electron-dark nav[role="navigation"] [class*="electron:opacity-75"],');
lines.push('.electron-light aside [class*="electron:opacity-75"],');
lines.push('.electron-dark aside [class*="electron:opacity-75"],');
lines.push('.electron-light nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-light nav[role="navigation"] .text-token-input-placeholder-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-input-placeholder-foreground {');
lines.push('  opacity: 1 !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light aside .text-token-description-foreground,');
lines.push('.electron-dark aside .text-token-description-foreground,');
lines.push('.electron-light aside .text-token-input-placeholder-foreground,');
lines.push('.electron-dark aside .text-token-input-placeholder-foreground,');
lines.push('.electron-light nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-light nav[role="navigation"] .text-token-input-placeholder-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-input-placeholder-foreground {');
lines.push('  color: var(--color-text-foreground-secondary) !important;');
lines.push('  opacity: 1 !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light .app-header-tint,');
lines.push('.electron-dark .app-header-tint {');
lines.push('  box-shadow: none !important;');
lines.push('}');
lines.push('');
lines.push('/* Hide debug-only navigation entries in production builds */');
lines.push('nav[role="navigation"] [aria-label="Debug"],');
lines.push('nav[role="navigation"] [title="Debug"],');
lines.push('nav[role="navigation"] a[href$="/debug"],');
lines.push('nav[role="navigation"] a[href*="/debug?"],');
lines.push('aside [aria-label="Debug"],');
lines.push('aside [title="Debug"],');
lines.push('aside a[href$="/debug"],');
lines.push('aside a[href*="/debug?"] {');
lines.push('  display: none !important;');
lines.push('}');

const nl = String.fromCharCode(10);
fs.writeFileSync(outFile, lines.join(nl) + nl, 'utf8');
NODE

INDEX_HTML="$index_html" node - <<'NODE'
const fs = require('fs');
const file = process.env.INDEX_HTML;
let html = fs.readFileSync(file, 'utf8');
const nl = String.fromCharCode(10);

html = html
  .split(nl)
  .filter((line) => !line.includes('linux-polish.css'))
  .join(nl);

if (!html.includes('linux-polish.css')) {
  html = html.replace('</head>', '    <link rel="stylesheet" href="./assets/linux-polish.css">' + nl + '</head>');
}

fs.writeFileSync(file, html, 'utf8');
NODE

cp "$css_file" "$inspect_dir/index.css"
cp "$assets_dir/linux-polish.css" "$inspect_dir/linux-polish.css"

echo "Synced linux polish in extracted bundle: $inspect_dir"
"""

[tasks."codex:ui:capture"]
description = "Run extracted app and capture live UI"
depends = ["codex:ui:sync-polish"]
run = """
set -euo pipefail
inspect_dir="{{config_root}}/.ui-inspect"
app_run="$inspect_dir/squashfs-root/AppRun"

if ! command -v agent-browser >/dev/null 2>&1; then
  echo "âŒ agent-browser not found" >&2
  exit 1
fi

if [ ! -x "$app_run" ]; then
  echo "âŒ Missing extracted AppRun at $app_run" >&2
  echo "Run: mise run codex:ui:extract" >&2
  exit 1
fi

# Kill any stale Codex/Electron from previous runs
pkill -f "AppRun.*remote-debugging-port" 2>/dev/null || true
if command -v xdotool >/dev/null 2>&1; then
  for w in $(xdotool search --name "Open project" 2>/dev/null || true); do
    xdotool windowclose "$w" 2>/dev/null || true
  done
fi
sleep 0.5

debug_port=$(node -e "const net=require('net');const s=net.createServer();s.listen(0,'127.0.0.1',()=>{process.stdout.write(String(s.address().port));s.close();});")

"$app_run" --remote-debugging-port="$debug_port" --remote-debugging-address=127.0.0.1 >/tmp/codex-ui-capture.log 2>&1 &
app_pid=$!

cleanup() {
  kill "$app_pid" >/dev/null 2>&1 || true
  sleep 0.3
  if command -v xdotool >/dev/null 2>&1; then
    for w in $(xdotool search --name "Open project" 2>/dev/null || true); do
      xdotool windowclose "$w" 2>/dev/null || true
    done
  fi
}
trap cleanup EXIT

ready=0
for _ in $(seq 1 80); do
  if curl -fsS "http://127.0.0.1:$debug_port/json/version" >/dev/null 2>&1; then
    ready=1
    break
  fi
  sleep 0.1
done

if [ "$ready" -ne 1 ]; then
  echo "âŒ Timed out waiting for debug port $debug_port" >&2
  exit 1
fi

sleep 1

agent-browser --cdp "$debug_port" snapshot -i --json > "$inspect_dir/codex-snapshot.json"
agent-browser --cdp "$debug_port" get title > "$inspect_dir/codex-title.txt"
agent-browser --cdp "$debug_port" screenshot --full --json > "$inspect_dir/codex-screenshot-meta.json"

node - <<'NODE'
const fs = require('fs');
const path = require('path');
const inspectDir = '{{config_root}}/.ui-inspect';
const meta = JSON.parse(fs.readFileSync(path.join(inspectDir, 'codex-screenshot-meta.json'), 'utf8'));
const src = meta && meta.data && meta.data.path;
if (!src || !fs.existsSync(src)) {
  throw new Error('screenshot path missing in codex-screenshot-meta.json');
}
fs.copyFileSync(src, path.join(inspectDir, 'codex-current.png'));
NODE

echo "Captured UI snapshot at $inspect_dir/codex-current.png"
"""

[tasks."codex:ui:design"]
description = "Use Claude CLI to generate candidate UI overrides"
depends = ["codex:ui:capture"]
run = """
set -euo pipefail
inspect_dir="{{config_root}}/.ui-inspect"
candidate_file="{{config_root}}/ui-design-overrides.candidate.json"
summary_file="$inspect_dir/theme-summary.json"
raw_file="$inspect_dir/claude-ui-response.json"
claude_model="${CLAUDE_MODEL:-claude-opus-4-6}"

if ! command -v claude >/dev/null 2>&1; then
  echo "âŒ claude CLI not found" >&2
  exit 1
fi

node - <<'NODE'
const fs = require('fs');
const path = require('path');

const inspectDir = '{{config_root}}/.ui-inspect';
const cssFile = path.join(inspectDir, 'index.css');
const outFile = path.join(inspectDir, 'theme-summary.json');
const candidateFile = '{{config_root}}/ui-design-overrides.candidate.json';
const pinnedFile = '{{config_root}}/ui-design-overrides.json';
const css = fs.readFileSync(cssFile, 'utf8');

let currentOverrides = {};
const sourceFile = fs.existsSync(candidateFile) ? candidateFile : pinnedFile;
if (fs.existsSync(sourceFile)) {
  try {
    const parsed = JSON.parse(fs.readFileSync(sourceFile, 'utf8'));
    if (parsed && parsed.token_overrides && typeof parsed.token_overrides === 'object') {
      currentOverrides = parsed.token_overrides;
    }
  } catch {
    currentOverrides = {};
  }
}

function collectThemeVars(selector) {
  const vars = {};
  const token = selector + '{';
  let pos = 0;
  while (true) {
    const start = css.indexOf(token, pos);
    if (start === -1) break;
    let i = start + token.length;
    let depth = 1;
    while (i < css.length && depth > 0) {
      const ch = css[i];
      if (ch === '{') depth += 1;
      else if (ch === '}') depth -= 1;
      i += 1;
    }
    const block = css.slice(start + token.length, i - 1);
    for (const decl of block.split(';')) {
      const idx = decl.indexOf(':');
      if (idx === -1) continue;
      const key = decl.slice(0, idx).trim();
      const value = decl.slice(idx + 1).trim();
      if (!key.startsWith('--')) continue;
      vars[key] = value;
    }
    pos = i;
  }
  return vars;
}

const light = collectThemeVars('.electron-light');
const dark = collectThemeVars('.electron-dark');
const focusKeys = [
  '--color-background-surface',
  '--color-background-surface-under',
  '--color-background-elevated-primary',
  '--color-background-elevated-primary-opaque',
  '--color-background-elevated-secondary',
  '--color-background-elevated-secondary-opaque',
  '--color-border',
  '--color-border-light',
  '--color-border-heavy',
  '--color-border-focus',
  '--color-text-foreground',
  '--color-text-foreground-secondary',
  '--color-text-foreground-tertiary',
  '--color-text-accent',
  '--color-text-button-secondary',
  '--color-icon-primary',
  '--color-icon-secondary',
  '--color-icon-tertiary',
  '--color-background-button-secondary',
  '--color-background-accent',
];

const summary = {
  focusTokens: focusKeys.map((key) => ({
    key,
    light: light[key] || null,
    dark: dark[key] || null,
    currentOverride: Object.prototype.hasOwnProperty.call(currentOverrides, key) ? currentOverrides[key] : null,
  })),
};

const nl = String.fromCharCode(10);
fs.writeFileSync(outFile, JSON.stringify(summary, null, 2) + nl, 'utf8');
NODE

schema='{"type":"object","properties":{"codex_titlebar_tint":{"type":"string"},"token_overrides":{"type":"object","additionalProperties":{"type":"string"}},"notes":{"type":"array","items":{"type":"string"}}},"required":["codex_titlebar_tint","token_overrides","notes"]}'

prompt=$(cat <<PROMPT
Design Linux UI overrides for Codex from this focused token summary:

$(cat "$summary_file")

Return stable, conservative overrides to make Linux look closer to a clean/light macOS style.
Constraints:
- Max 20 token_overrides entries.
- Use only semantic tokens (prefer --color-background-*, --color-text-*, --color-border-*).
- Avoid brittle selectors/components.
- Keep contrast readable and avoid flashy styling.
- Prioritize sidebar legibility and avoid washed-out thread labels.
PROMPT
)

run_claude() {
  local model_name="$1"
  claude -p --model "$model_name" --permission-mode dontAsk --output-format json --json-schema "$schema" "$prompt" > "$raw_file"
}

if ! run_claude "$claude_model"; then
  if [ "$claude_model" = "opus" ]; then
    exit 1
  fi
  echo "âš ï¸ Model '$claude_model' unavailable, retrying with --model opus" >&2
  run_claude "opus"
fi

node - <<'NODE'
const fs = require('fs');
const rawFile = '{{config_root}}/.ui-inspect/claude-ui-response.json';
const outFile = '{{config_root}}/ui-design-overrides.candidate.json';
const raw = JSON.parse(fs.readFileSync(rawFile, 'utf8'));
const parsed = raw.structured_output || raw;
if (!parsed || typeof parsed !== 'object') throw new Error('Invalid JSON root');
if (typeof parsed.codex_titlebar_tint !== 'string') throw new Error('Missing codex_titlebar_tint');
if (!parsed.token_overrides || typeof parsed.token_overrides !== 'object') throw new Error('Missing token_overrides');
const entries = Object.entries(parsed.token_overrides);
if (entries.length > 20) throw new Error('Too many token overrides (max 20)');
for (const [k, v] of entries) {
  if (!k.startsWith('--')) throw new Error(`Invalid token key: ${k}`);
  if (typeof v !== 'string') throw new Error(`Invalid token value for ${k}`);
}
const nl = String.fromCharCode(10);
fs.writeFileSync(outFile, JSON.stringify(parsed, null, 2) + nl, 'utf8');
console.log('ui-design-overrides.candidate.json validated');
NODE
"""

[tasks."codex:ui:pin"]
description = "Promote candidate overrides to pinned overrides"
run = """
set -euo pipefail
candidate_file="{{config_root}}/ui-design-overrides.candidate.json"
pinned_file="{{config_root}}/ui-design-overrides.json"

if [ ! -s "$candidate_file" ]; then
  echo "âŒ Candidate overrides missing: $candidate_file" >&2
  exit 1
fi

cp "$candidate_file" "$pinned_file"
echo "Pinned overrides updated: $pinned_file"
"""

[tasks."codex:ui:iterate"]
description = "Fast loop: apply overrides and capture screenshot"
depends = ["codex:ui:capture"]
run = """
echo "Updated screenshot: .ui-inspect/codex-current.png"
"""

[tasks."codex:ui:loop"]
description = "Generate candidate with Claude and print next steps"
depends = ["codex:ui:design"]
run = """
echo "UI candidate generated: ui-design-overrides.candidate.json"
echo "Review then run:"
echo "  mise run codex:ui:pin"
echo "  mise run codex:ui:iterate"
echo "Build AppImage only when happy with result:"
echo "  mise run codex:build"
"""

[tasks."codex:release"]
description = "Build AppImage and publish/update GitHub release"
depends = ["codex:build"]
run = """
set -euo pipefail
appimage_path="{{config_root}}/Codex.AppImage"
versions_file="{{config_root}}/versions.json"

if ! command -v gh >/dev/null 2>&1; then
  echo "âŒ GitHub CLI (gh) not found" >&2
  exit 1
fi

gh auth status >/dev/null 2>&1 || {
  echo "âŒ gh is not authenticated. Run: gh auth login" >&2
  exit 1
}

app_version="$(jq -r '.app' "$versions_file")"
cli_version="$(jq -r '.cli' "$versions_file")"

if [ -z "$app_version" ] || [ "$app_version" = "null" ]; then
  echo "âŒ Invalid app version in $versions_file" >&2
  exit 1
fi

tag="v$app_version"
title="Codex AppImage $app_version"
notes="Automated AppImage release for Codex app $app_version (CLI $cli_version)."

if gh release view "$tag" >/dev/null 2>&1; then
  gh release upload "$tag" "$appimage_path" --clobber
  gh release edit "$tag" --title "$title" --notes "$notes"
else
  gh release create "$tag" "$appimage_path" --title "$title" --notes "$notes"
fi
"""

[tasks."codex:cleanup"]
description = "Remove temporary build cache directories (Linux + Windows)"
run = "rm -rf {{env.WORKDIR}}/docker-output {{env.WORKDIR}}/docker-output-windows {{env.WORKDIR}}/native-build-host"

[tasks."codex:build"]
description = "Build Codex AppImage end-to-end"
depends = ["codex:versions"]
run = """
echo ""
echo "âœ… Build complete!"
echo "ðŸ“¦ AppImage: {{config_root}}/Codex.AppImage"
echo "ðŸ“„ Versions: {{config_root}}/versions.json"
echo "Run GUI: {{config_root}}/Codex.AppImage"
echo "Run CLI: {{config_root}}/Codex.AppImage --cli --help"
"""

# â”€â”€ Linux x64 build tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Build Linux CLI binary locally and commit for GitHub Actions

[tasks."codex:linux:compile"]
description = "Build Linux codex binary and stage at dist/linux-x64/ for commit"
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output-linux"
dist_dir="{{config_root}}/dist/linux-x64"
mkdir -p "$docker_output_dir"

docker run --rm \
  --entrypoint bash \
  -e CODEX_GIT_REF="{{env.CODEX_GIT_REF}}" \
  -v "$docker_output_dir:/output" \
  codex-builder -c '
set -euo pipefail
mkdir -p /output/work
cd /output/work

rm -rf codex-src
git clone https://github.com/openai/codex.git codex-src >/dev/null

cd codex-src
if [ "$CODEX_GIT_REF" = "latest-tag" ]; then
  git fetch --tags --force >/dev/null 2>&1 || true
  SELECTED_TAG=""
  for tag in $(git tag --sort=-v:refname | head -n 200); do
    git checkout --detach "$tag" >/dev/null 2>&1 || continue
    if cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
      SELECTED_TAG="$tag"
      break
    fi
  done
  if [ -z "$SELECTED_TAG" ]; then
    echo "No buildable codex ref found" >&2
    exit 1
  fi
else
  git fetch --depth 1 origin "$CODEX_GIT_REF" >/dev/null
  git checkout --detach FETCH_HEAD >/dev/null
  if ! cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
    echo "Selected ref $CODEX_GIT_REF is not buildable" >&2
    exit 1
  fi
fi

cd codex-rs
echo "Building codex CLI for Linux x86_64..."
# Build the full workspace (now that Docker image has libcap-dev)
cargo build --release --bin codex --bin codex-linux-sandbox 2>&1 || {
  echo "Full build failed, trying codex only..."
  cargo build --release --bin codex
}
echo "codex binary built successfully"

cp target/release/codex /output/codex
if [ -f target/release/codex-linux-sandbox ]; then
  cp target/release/codex-linux-sandbox /output/codex-linux-sandbox
fi
echo "Linux codex binary built successfully"
'

mkdir -p "$dist_dir"
cp -f "$docker_output_dir/codex" "$dist_dir/codex"
if [ -f "$docker_output_dir/codex-linux-sandbox" ]; then
  cp -f "$docker_output_dir/codex-linux-sandbox" "$dist_dir/codex-linux-sandbox"
fi
file "$dist_dir/codex" | grep -qi "ELF.*Linux"

echo ""
echo "âœ… Linux codex binary staged at: dist/linux-x64/codex"
echo ""
echo "Next steps:"
echo "  git add dist/linux-x64/"
echo "  git commit -m \"chore: update Linux codex binary\""
echo "  git push"
"""

# â”€â”€ Windows x64 cross-compile tasks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# These tasks cross-compile the Rust CLI for Windows from Linux using MinGW.
# The binary is committed to dist/windows-x64/codex.exe so that GitHub Actions
# only needs to handle native Node modules + Electron packaging (no Rust build).
#
# Cross-compile and commit the CLI:
#   mise run codex:win:compile   â†’ builds codex.exe, stages to dist/
#   git add dist/ && git commit && git push
# Then trigger the CI (picks up committed binary):
#   mise run codex:win:ci

[tasks."codex:win:docker-build"]
description = "Build Windows cross-compile Docker image"
run = "docker build -f {{config_root}}/Dockerfile.windows -t codex-windows-builder {{config_root}}"

[tasks."codex:win:compile"]
description = "Cross-compile codex.exe and stage at dist/windows-x64/ for commit"
depends = ["codex:win:docker-build"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output-windows"
dist_dir="{{config_root}}/dist/windows-x64"
mkdir -p "$docker_output_dir"

docker run --rm \
  --entrypoint bash \
  -e CODEX_GIT_REF="{{env.CODEX_GIT_REF}}" \
  -v "$docker_output_dir:/output" \
  codex-windows-builder -c '
set -euo pipefail
mkdir -p /output/work
cd /output/work

rm -rf codex-src
git clone https://github.com/openai/codex.git codex-src >/dev/null

cd codex-src
if [ "$CODEX_GIT_REF" = "latest-tag" ]; then
  git fetch --tags --force >/dev/null 2>&1 || true
  SELECTED_TAG=""
  for tag in $(git tag --sort=-v:refname | head -n 200); do
    git checkout --detach "$tag" >/dev/null 2>&1 || continue
    if cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
      SELECTED_TAG="$tag"
      break
    fi
  done
  if [ -z "$SELECTED_TAG" ]; then
    echo "No buildable codex ref found" >&2
    exit 1
  fi
else
  git fetch --depth 1 origin "$CODEX_GIT_REF" >/dev/null
  git checkout --detach FETCH_HEAD >/dev/null
  if ! cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
    echo "Selected ref $CODEX_GIT_REF is not buildable" >&2
    exit 1
  fi
fi

cd codex-rs
echo "Building codex CLI for x86_64-pc-windows-gnu..."
cargo build --release --target x86_64-pc-windows-gnu --bin codex

cp target/x86_64-pc-windows-gnu/release/codex.exe /output/codex.exe
echo "codex.exe built successfully"
'

mkdir -p "$dist_dir"
cp -f "$docker_output_dir/codex.exe" "$dist_dir/codex.exe"
file "$dist_dir/codex.exe" | grep -qi "PE32\\|Windows"

echo ""
echo "\\u2705 codex.exe cross-compiled and staged at: dist/windows-x64/codex.exe"
echo ""
echo "Next steps:"
echo "  git add dist/windows-x64/codex.exe"
echo "  git commit -m \\"chore: update cross-compiled codex.exe for Windows x64\\""
echo "  git push"
echo "  mise run codex:win:ci"
"""

[tasks."codex:win:docker-run"]
description = "Extract DMG/ASAR and cross-compile Rust CLI for Windows x64"
depends = ["codex:win:docker-build"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output-windows"
rm -rf "$docker_output_dir"
mkdir -p "$docker_output_dir"

if [ -f "{{config_root}}/ui-design-overrides.json" ]; then
  cp "{{config_root}}/ui-design-overrides.json" "$docker_output_dir/ui-design-overrides.json"
fi

docker run --rm \
  --entrypoint bash \
  --cap-add SYS_ADMIN \
  --security-opt apparmor:unconfined \
  -e WORKDIR=/output/work \
  -e CODEX_DMG_URL="{{env.CODEX_DMG_URL}}" \
  -e ENABLE_LINUX_UI_POLISH="{{env.ENABLE_LINUX_UI_POLISH}}" \
  -e CODEX_GIT_REF="{{env.CODEX_GIT_REF}}" \
  -e UI_OVERRIDES_FILE=/output/ui-design-overrides.json \
  -v "$docker_output_dir:/output" \
  codex-windows-builder -c '
set -euo pipefail
mkdir -p "$WORKDIR"
cd "$WORKDIR"

# â”€â”€ Download & extract DMG (reuse if cached) â”€â”€
if [ ! -f Codex.dmg ]; then
  if command -v curl >/dev/null 2>&1; then
    curl -L --fail --output Codex.dmg "$CODEX_DMG_URL"
  else
    wget -O Codex.dmg "$CODEX_DMG_URL"
  fi
fi

rm -f Codex.img
dmg2img Codex.dmg Codex.img

rm -rf extracted app_unpacked
mkdir -p extracted
7z x Codex.img -oextracted/ -y >/dev/null || true

ASAR_PATH=$(find extracted -name app.asar -type f | head -1)
if [ -z "$ASAR_PATH" ]; then
  echo "Could not locate app.asar" >&2
  exit 1
fi

NODE_MAJOR=$(node -v | sed -E "s/^v([0-9]+).*/\\1/")
ASAR_PKG="@electron/asar"
if [ "$NODE_MAJOR" -lt 22 ]; then
  ASAR_PKG="@electron/asar@3.2.13"
fi

mkdir -p .npm-local
npm init -y --prefix .npm-local >/dev/null 2>&1 || true
npm install --prefix .npm-local "$ASAR_PKG" >/dev/null
.npm-local/node_modules/.bin/asar extract "$ASAR_PATH" app_unpacked/

# â”€â”€ Clone & build Rust CLI for Windows â”€â”€
rm -rf codex-src
git clone https://github.com/openai/codex.git codex-src >/dev/null

cd codex-src
if [ "$CODEX_GIT_REF" = "latest-tag" ]; then
  git fetch --tags --force >/dev/null 2>&1 || true
  SELECTED_TAG=""
  for tag in $(git tag --sort=-v:refname | head -n 200); do
    git checkout --detach "$tag" >/dev/null 2>&1 || continue
    if cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
      SELECTED_TAG="$tag"
      break
    fi
  done
  if [ -z "$SELECTED_TAG" ]; then
    git checkout --detach HEAD >/dev/null 2>&1
    cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1 || {
      echo "No buildable codex ref found" >&2
      exit 1
    }
  fi
else
  git fetch --depth 1 origin "$CODEX_GIT_REF" >/dev/null
  git checkout --detach FETCH_HEAD >/dev/null
  if ! cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
    echo "Selected ref $CODEX_GIT_REF is not buildable" >&2
    cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps
    exit 1
  fi
fi

cd codex-rs
echo "Building codex CLI for x86_64-pc-windows-gnu..."
cargo build --release --target x86_64-pc-windows-gnu --bin codex

# â”€â”€ Assemble Windows bundle â”€â”€
cd "$WORKDIR/app_unpacked"
rm -f native/sparkle.node
rm -rf node_modules/electron-liquid-glass

mkdir -p resources resources/bin
cp "$WORKDIR/codex-src/codex-rs/target/x86_64-pc-windows-gnu/release/codex.exe" resources/codex.exe
chmod +x resources/codex.exe
cp resources/codex.exe resources/bin/codex.exe

# â”€â”€ Windows launcher scripts â”€â”€
# Note: backslashes are doubled for TOML escape handling
cat > codex-windows.bat <<"LAUNCHER_BAT"
@echo off
set "APP_DIR=%~dp0"
set "PATH=%APP_DIR%resources;%APP_DIR%resources\\bin;%PATH%"
set "CODEX_CLI_PATH=%APP_DIR%resources\\bin\\codex.exe"

if not exist "%CODEX_CLI_PATH%" (
  echo codex.exe not found at %CODEX_CLI_PATH% >&2
  exit /b 1
)

if "%~1"=="--cli" (
  shift
  "%CODEX_CLI_PATH%" %*
  exit /b %ERRORLEVEL%
)

where electron >nul 2>nul
if %ERRORLEVEL% equ 0 (
  electron "%APP_DIR%" %*
) else (
  echo Electron not installed. Run CLI: %CODEX_CLI_PATH%
  echo   codex-windows.bat --cli --help
  exit /b 1
)
LAUNCHER_BAT

cat > codex-windows.ps1 <<"LAUNCHER_PS1"
$AppDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$env:PATH = "$AppDir\\resources;$AppDir\\resources\\bin;$env:PATH"
$env:CODEX_CLI_PATH = "$AppDir\\resources\\bin\\codex.exe"

if (-not (Test-Path $env:CODEX_CLI_PATH)) {
  Write-Error "codex.exe not found at $env:CODEX_CLI_PATH"
  exit 1
}

if ($args -and $args[0] -eq "--cli") {
  $cliArgs = $args[1..($args.Length - 1)]
  & $env:CODEX_CLI_PATH @cliArgs
  exit $LASTEXITCODE
}

$electronPath = Get-Command electron -ErrorAction SilentlyContinue
if ($electronPath) {
  & electron $AppDir @args
} else {
  Write-Host "Electron not installed. Run CLI: $env:CODEX_CLI_PATH"
  Write-Host "  .\\codex-windows.ps1 --cli --help"
  exit 1
}
LAUNCHER_PS1
'
"""

[tasks."codex:win:prepare-bundle"]
description = "Copy Windows bundle to stable cache path"
depends = ["codex:win:docker-run"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output-windows"
bundle_dir="$docker_output_dir/codex-windows"

if [ -d "$docker_output_dir/work/app_unpacked" ]; then
  rm -rf "$bundle_dir"
  cp -a "$docker_output_dir/work/app_unpacked" "$bundle_dir"
fi

if [ ! -d "$bundle_dir" ]; then
  echo "âŒ Missing app bundle after Docker build" >&2
  exit 1
fi

# Verify the cross-compiled binary exists
if [ ! -f "$bundle_dir/resources/codex.exe" ]; then
  echo "âŒ codex.exe not found in bundle" >&2
  exit 1
fi
file "$bundle_dir/resources/codex.exe" | grep -qi "PE32\\|Windows"
"""

[tasks."codex:win:package"]
description = "Package Windows bundle as a portable zip"
depends = ["codex:win:prepare-bundle"]
run = """
set -euo pipefail
bundle_dir="{{env.WORKDIR}}/docker-output-windows/codex-windows"
output_path="{{config_root}}/Codex-Windows-x64.zip"

if [ ! -d "$bundle_dir" ]; then
  echo "âŒ Windows bundle not found at $bundle_dir" >&2
  exit 1
fi

rm -f "$output_path"

# Create a clean directory name for the zip contents
staging_dir=$(mktemp -d)
cp -a "$bundle_dir" "$staging_dir/codex-windows-x64"

(cd "$staging_dir" && 7z a -tzip "$output_path" codex-windows-x64/)
rm -rf "$staging_dir"

echo ""
echo "ðŸ“¦ Windows zip: $output_path"
echo ""
echo "âš ï¸  NOTE: This bundle has the cross-compiled Rust CLI (MinGW/GNU)"
echo "    but native Node modules (better-sqlite3, node-pty) are still"
echo "    Linux ELF binaries. The Electron GUI will NOT work on Windows"
echo "    until native modules are rebuilt on a real Windows machine."
echo ""
echo "    For a complete Windows build with working native modules, use:"
echo "      mise run codex:win:ci"
echo "    or run the GitHub Actions workflow manually."
echo ""
echo "    The CLI binary (codex.exe --cli) should work standalone on Windows."
"""

[tasks."codex:win:build"]
description = "Cross-compile Windows bundle from Linux (CLI only â€” native modules need Windows)"
depends = ["codex:win:package"]
run = """
echo ""
echo "âœ… Windows cross-compile complete!"
echo "ðŸ“¦ Zip: {{config_root}}/Codex-Windows-x64.zip"
echo ""
echo "This contains a working codex.exe CLI built with MinGW."
echo "For the full Electron app, run: mise run codex:win:ci"
"""

[tasks."codex:win:ci"]
description = "Trigger GitHub Actions workflow for full Windows Electron build"
run = """
set -euo pipefail

if ! command -v gh >/dev/null 2>&1; then
  echo "âŒ GitHub CLI (gh) not found" >&2
  exit 1
fi

gh auth status >/dev/null 2>&1 || {
  echo "âŒ gh is not authenticated. Run: gh auth login" >&2
  exit 1
}

echo "Triggering Windows build workflow on GitHub Actions..."
gh workflow run build-windows.yml \
  --field codex_git_ref="{{env.CODEX_GIT_REF}}"

echo ""
echo "âœ… Workflow dispatched!"
echo "Watch progress: gh run list --workflow=build-windows.yml"
echo "Or open: $(gh repo view --json url -q .url)/actions/workflows/build-windows.yml"
"""

[tasks."codex:win:cleanup"]
description = "Remove Windows build cache directories"
run = "rm -rf {{env.WORKDIR}}/docker-output-windows"

[settings]
jobs = 4
