# Mise configuration for Codex Linux AppImage workflow

[tools]
node = "22"
jq = "1.7.1"

[env]
WORKDIR = "{{env.HOME}}/.cache/codex-linux-port"
CODEX_DMG_URL = "https://persistent.oaistatic.com/codex-app-prod/Codex.dmg"
ENABLE_LINUX_UI_POLISH = "1"
CODEX_GIT_REF = "rust-v0.102.0-alpha.7"
CODEX_SKIP_RUST_BUILD = "1"
CODEX_PREBUILT_CLI_URL = "https://github.com/openai/codex/releases/download/rust-v0.102.0-alpha.7/codex-x86_64-unknown-linux-gnu.tar.gz"
CODEX_PREBUILT_SANDBOX_URL = ""

[tasks."codex:docker-build"]
description = "Build codex-builder Docker image"
run = """
set -euo pipefail
if docker image inspect codex-builder >/dev/null 2>&1; then
  echo "codex-builder already present; skipping docker build"
  exit 0
fi
docker build -t codex-builder {{config_root}}
"""

[tasks."codex:docker-run"]
description = "Run extraction and Rust build in container"
depends = ["codex:docker-build"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output"

# The container runs as root (needs SYS_ADMIN) and writes into the bind mount.
# Without an explicit chown, that leaves root-owned files in WORKDIR which then
# breaks subsequent runs when the host user tries to `rm -rf`.
host_uid="$(id -u)"
host_gid="$(id -g)"

# Always (re)create the output directory from inside a container so we can
# reliably delete root-owned leftovers without sudo on the host.
docker run --rm \
  --entrypoint bash \
  -e HOST_UID="$host_uid" \
  -e HOST_GID="$host_gid" \
  -v "{{env.WORKDIR}}:/workdir" \
  -v "{{config_root}}:/config:ro" \
  codex-builder -c '
set -euo pipefail
rm -rf /workdir/docker-output
mkdir -p /workdir/docker-output
if [ -f /config/ui-design-overrides.json ]; then
  cp /config/ui-design-overrides.json /workdir/docker-output/ui-design-overrides.json
fi
chown -R "$HOST_UID:$HOST_GID" /workdir/docker-output
'

docker run --rm \
  --entrypoint bash \
  --cap-add SYS_ADMIN \
  --security-opt apparmor:unconfined \
  -e HOST_UID="$host_uid" \
  -e HOST_GID="$host_gid" \
  -e WORKDIR=/output/work \
  -e CODEX_DMG_URL="{{env.CODEX_DMG_URL}}" \
  -e CODEX_SKIP_RUST_BUILD="{{env.CODEX_SKIP_RUST_BUILD}}" \
  -e CODEX_PREBUILT_CLI_URL="{{env.CODEX_PREBUILT_CLI_URL}}" \
  -e CODEX_PREBUILT_SANDBOX_URL="{{env.CODEX_PREBUILT_SANDBOX_URL}}" \
  -e ENABLE_LINUX_UI_POLISH="{{env.ENABLE_LINUX_UI_POLISH}}" \
  -e CODEX_GIT_REF="{{env.CODEX_GIT_REF}}" \
  -e UI_OVERRIDES_FILE=/output/ui-design-overrides.json \
  -v "$docker_output_dir:/output" \
  codex-builder -c '
set -euo pipefail
mkdir -p "$WORKDIR"
cd "$WORKDIR"
SKIP_RUST_BUILD="${CODEX_SKIP_RUST_BUILD:-0}"
PREBUILT_WIN_CLI_URL="${CODEX_PREBUILT_WIN_CLI_URL:-}"
SKIP_RUST_BUILD="${CODEX_SKIP_RUST_BUILD:-0}"
PREBUILT_CLI_URL="${CODEX_PREBUILT_CLI_URL:-}"
PREBUILT_SANDBOX_URL="${CODEX_PREBUILT_SANDBOX_URL:-}"

if [ ! -f Codex.dmg ]; then
  if command -v curl >/dev/null 2>&1; then
    curl -L --fail --output Codex.dmg "$CODEX_DMG_URL"
  else
    wget -O Codex.dmg "$CODEX_DMG_URL"
  fi
fi

rm -f Codex.img
dmg2img Codex.dmg Codex.img

rm -rf extracted app_unpacked
mkdir -p extracted
7z x Codex.img -oextracted/ -y >/dev/null || true

ASAR_PATH=$(find extracted -name app.asar -type f | head -1)
if [ -z "$ASAR_PATH" ]; then
  echo "Could not locate app.asar" >&2
  exit 1
fi

NODE_MAJOR=$(node -v | sed -E "s/^v([0-9]+).*/\\1/")
ASAR_PKG="@electron/asar"
if [ "$NODE_MAJOR" -lt 22 ]; then
  ASAR_PKG="@electron/asar@3.2.13"
fi

mkdir -p .npm-local
npm init -y --prefix .npm-local >/dev/null 2>&1 || true
npm install --prefix .npm-local "$ASAR_PKG" >/dev/null
.npm-local/node_modules/.bin/asar extract "$ASAR_PATH" app_unpacked/

rm -rf codex-src
if [ "$SKIP_RUST_BUILD" = "1" ]; then
  if [ -z "$PREBUILT_CLI_URL" ]; then
    echo "CODEX_SKIP_RUST_BUILD is set but CODEX_PREBUILT_CLI_URL is missing" >&2
    exit 1
  fi

  rm -rf "$WORKDIR/prebuilt"
  mkdir -p "$WORKDIR/prebuilt"
  PREBUILT_CLI_ARCHIVE="$WORKDIR/prebuilt/codex.prebuilt"
  if command -v curl >/dev/null 2>&1; then
    curl -L --fail --output "$PREBUILT_CLI_ARCHIVE" "$PREBUILT_CLI_URL"
  else
    wget -O "$PREBUILT_CLI_ARCHIVE" "$PREBUILT_CLI_URL"
  fi

PREBUILT_CLI_PATH=""
  case "$PREBUILT_CLI_URL" in
    *.tar.gz|*.tgz)
      tar -xzf "$PREBUILT_CLI_ARCHIVE" -C "$WORKDIR/prebuilt"
      PREBUILT_CLI_PATH="$(find "$WORKDIR/prebuilt" -maxdepth 1 -type f ! -name 'codex.prebuilt' | head -n 1)"
      ;;
    *.zst)
      if ! command -v zstd >/dev/null 2>&1; then
        echo "zstd is required to extract prebuilt CLI from $PREBUILT_CLI_URL" >&2
        exit 1
      fi
      unzstd -c "$PREBUILT_CLI_ARCHIVE" > "$WORKDIR/prebuilt/codex-x86_64-unknown-linux-gnu"
      PREBUILT_CLI_PATH="$WORKDIR/prebuilt/codex-x86_64-unknown-linux-gnu"
      ;;
    *)
      PREBUILT_CLI_PATH="$PREBUILT_CLI_ARCHIVE"
      ;;
  esac

  if [ -z "$PREBUILT_CLI_PATH" ] || [ ! -f "$PREBUILT_CLI_PATH" ]; then
    echo "Could not extract a prebuilt codex CLI binary from $PREBUILT_CLI_URL" >&2
    exit 1
  fi

  cp "$PREBUILT_CLI_PATH" "$WORKDIR/prebuilt/codex"
  chmod +x "$WORKDIR/prebuilt/codex"

  if [ -n "$PREBUILT_SANDBOX_URL" ]; then
    if command -v curl >/dev/null 2>&1; then
      curl -L --fail --output "$WORKDIR/prebuilt/codex-linux-sandbox" "$PREBUILT_SANDBOX_URL"
    else
      wget -O "$WORKDIR/prebuilt/codex-linux-sandbox" "$PREBUILT_SANDBOX_URL"
    fi
    chmod +x "$WORKDIR/prebuilt/codex-linux-sandbox"
  fi
else
  git clone https://github.com/openai/codex.git codex-src >/dev/null

  cd codex-src
  if [ "$CODEX_GIT_REF" = "latest-tag" ]; then
    git fetch --tags --force >/dev/null 2>&1 || true
    SELECTED_TAG=""
    for tag in $(git tag --sort=-v:refname | head -n 200); do
      git checkout --detach "$tag" >/dev/null 2>&1 || continue
      if cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
        SELECTED_TAG="$tag"
        break
      fi
    done
    if [ -z "$SELECTED_TAG" ]; then
      git checkout --detach HEAD >/dev/null 2>&1
      cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1 || {
        echo "No buildable codex ref found" >&2
        exit 1
      }
    fi
  else
    git fetch --depth 1 origin "$CODEX_GIT_REF" >/dev/null
    git checkout --detach FETCH_HEAD >/dev/null
    if ! cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps >/dev/null 2>&1; then
      echo "Selected ref $CODEX_GIT_REF is not buildable" >&2
      cargo metadata --manifest-path codex-rs/Cargo.toml --no-deps
      exit 1
    fi
  fi

  cd codex-rs
  cargo build --release --bin codex
  cargo build --release --bin codex-linux-sandbox || true
fi

cd "$WORKDIR/app_unpacked"
rm -f native/sparkle.node
rm -rf node_modules/electron-liquid-glass

mkdir -p resources resources/bin
if [ "$SKIP_RUST_BUILD" = "1" ]; then
  cp "$WORKDIR/prebuilt/codex" resources/codex
  chmod +x resources/codex
  cp resources/codex resources/bin/codex
  chmod +x resources/bin/codex
else
  cp "$WORKDIR/codex-src/codex-rs/target/release/codex" resources/codex
  chmod +x resources/codex
  cp resources/codex resources/bin/codex
  chmod +x resources/bin/codex
fi

if [ "$SKIP_RUST_BUILD" != "1" ] && [ -f "$WORKDIR/codex-src/codex-rs/target/release/codex-linux-sandbox" ]; then
  cp "$WORKDIR/codex-src/codex-rs/target/release/codex-linux-sandbox" resources/
  chmod +x resources/codex-linux-sandbox
elif [ "$SKIP_RUST_BUILD" = "1" ] && [ -f "$WORKDIR/prebuilt/codex-linux-sandbox" ]; then
  cp "$WORKDIR/prebuilt/codex-linux-sandbox" resources/
  chmod +x resources/codex-linux-sandbox
fi

if [ "$ENABLE_LINUX_UI_POLISH" = "1" ]; then
  css_file=$(ls webview/assets/index-*.css 2>/dev/null | head -1 || true)
  if [ -n "$css_file" ]; then
    CSS_FILE="$css_file" node - <<"NODE"
const fs = require("fs");

const cssFile = process.env.CSS_FILE;
const css = fs.readFileSync(cssFile, "utf8");
const overridePath = process.env.UI_OVERRIDES_FILE || "";

let manualTokenOverrides = {};
let manualTitlebarTint = "";
if (overridePath && fs.existsSync(overridePath)) {
  try {
    const parsed = JSON.parse(fs.readFileSync(overridePath, "utf8"));
    if (parsed && typeof parsed === "object") {
      if (parsed.token_overrides && typeof parsed.token_overrides === "object") {
        manualTokenOverrides = parsed.token_overrides;
      }
      if (typeof parsed.codex_titlebar_tint === "string" && parsed.codex_titlebar_tint.trim()) {
        manualTitlebarTint = parsed.codex_titlebar_tint.trim();
      }
    }
  } catch {
    manualTokenOverrides = {};
    manualTitlebarTint = "";
  }
}

function readThemeVar(selector, key) {
  const token = selector + "{";
  let pos = 0;
  while (true) {
    const start = css.indexOf(token, pos);
    if (start === -1) return "";
    let i = start + token.length;
    let depth = 1;
    while (i < css.length && depth > 0) {
      const ch = css[i];
      if (ch === "{") depth += 1;
      else if (ch === "}") depth -= 1;
      i += 1;
    }
    const block = css.slice(start + token.length, i - 1);
    for (const decl of block.split(";")) {
      const idx = decl.indexOf(":");
      if (idx === -1) continue;
      const declKey = decl.slice(0, idx).trim();
      const value = decl.slice(idx + 1).trim();
      if (declKey === key) return value;
    }
    pos = i;
  }
}

const semanticDefaults = {
  "--color-background-surface": readThemeVar(".electron-light", "--color-background-surface") || "var(--gray-0)",
  "--color-background-surface-under": readThemeVar(".electron-light", "--color-background-surface-under") || "var(--gray-0)",
  "--color-background-elevated-primary": readThemeVar(".electron-light", "--color-background-elevated-primary") || "color-mix(in oklab, var(--gray-0) 88%, transparent)",
  "--color-background-elevated-secondary": readThemeVar(".electron-light", "--color-background-elevated-secondary") || "color-mix(in oklab, var(--gray-1000) 2%, transparent)",
  "--color-border": readThemeVar(".electron-light", "--color-border") || "color-mix(in oklab, var(--gray-1000) 8%, transparent)",
  "--color-text-foreground": readThemeVar(".electron-light", "--color-text-foreground") || "var(--gray-1000)",
  "--color-text-foreground-secondary": readThemeVar(".electron-light", "--color-text-foreground-secondary") || "color-mix(in oklab, var(--gray-1000) 70%, transparent)",
  "--color-icon-primary": readThemeVar(".electron-light", "--color-icon-primary") || "var(--gray-1000)",
};

const lines = [];
lines.push("/* Auto-generated Linux polish: conservative semantic overrides */");
lines.push(".electron-light,");
lines.push(".electron-dark {");
lines.push("  color-scheme: light;");
for (const [key, value] of Object.entries(semanticDefaults)) {
  lines.push(`  ${key}: ${value};`);
}
for (const [key, value] of Object.entries(manualTokenOverrides)) {
  if (typeof key !== "string" || typeof value !== "string") continue;
  if (!key.startsWith("--")) continue;
  lines.push(`  ${key}: ${value};`);
}
const titlebarTint = manualTitlebarTint || "color-mix(in oklab, var(--blue-100) 42%, transparent)";
lines.push(`  --codex-titlebar-tint: ${titlebarTint};`);
lines.push("}");
lines.push("");
lines.push("/* Keep structure untouched; token-only overrides for stability */");
lines.push(".electron-light aside,");
lines.push(".electron-dark aside,");
lines.push(`.electron-light [role="navigation"],`);
lines.push(`.electron-dark [role="navigation"] {`);
lines.push("  box-shadow: none !important;");
lines.push("  background-color: var(--color-background-surface) !important;");
lines.push("  opacity: 1 !important;");
lines.push("  filter: none !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light nav[role=\\\"navigation\\\"],");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] {");
lines.push("  mask-image: none !important;");
lines.push("  -webkit-mask-image: none !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light nav[role=\\\"navigation\\\"] button.opacity-75:not(:disabled),");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] button.opacity-75:not(:disabled),");
lines.push(".electron-light nav[role=\\\"navigation\\\"] [role=\\\"button\\\"].opacity-75:not([aria-disabled=\\\"true\\\"]),");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] [role=\\\"button\\\"].opacity-75:not([aria-disabled=\\\"true\\\"]) {");
lines.push("  opacity: 1 !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light nav[role=\\\"navigation\\\"] [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-light aside [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-dark aside [class*=\\\"electron:opacity-75\\\"],");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground {");
lines.push("  opacity: 1 !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light aside .text-token-description-foreground,");
lines.push(".electron-dark aside .text-token-description-foreground,");
lines.push(".electron-light aside .text-token-input-placeholder-foreground,");
lines.push(".electron-dark aside .text-token-input-placeholder-foreground,");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-description-foreground,");
lines.push(".electron-light nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground,");
lines.push(".electron-dark nav[role=\\\"navigation\\\"] .text-token-input-placeholder-foreground {");
lines.push("  color: var(--color-text-foreground-secondary) !important;");
lines.push("  opacity: 1 !important;");
lines.push("}");
lines.push("");
lines.push(".electron-light .app-header-tint,");
lines.push(".electron-dark .app-header-tint {");
lines.push("  box-shadow: none !important;");
lines.push("}");
lines.push("");
lines.push("/* Hide debug-only navigation entries in production builds */");
lines.push("nav[role=\\\"navigation\\\"] [aria-label=\\\"Debug\\\"],");
lines.push("nav[role=\\\"navigation\\\"] [title=\\\"Debug\\\"],");
lines.push("nav[role=\\\"navigation\\\"] a[href$=\\\"/debug\\\"],");
lines.push("nav[role=\\\"navigation\\\"] a[href*=\\\"/debug?\\\"],");
lines.push("aside [aria-label=\\\"Debug\\\"],");
lines.push("aside [title=\\\"Debug\\\"],");
lines.push("aside a[href$=\\\"/debug\\\"],");
lines.push("aside a[href*=\\\"/debug?\\\"] {");
lines.push("  display: none !important;");
lines.push("}");

const nl = String.fromCharCode(10);
fs.writeFileSync("webview/assets/linux-polish.css", lines.join(nl) + nl, "utf8");
console.log("generated linux-polish.css with conservative semantic overrides");
NODE
  fi

  node - <<"NODE"
const fs = require("fs");
const file = "webview/index.html";
let html = fs.readFileSync(file, "utf8");
const nl = String.fromCharCode(10);

html = html
  .split(nl)
  .filter((line) => !line.includes("linux-polish.css"))
  .join(nl);

if (!html.includes("linux-polish.css")) {
  html = html.replace("</head>", `    <link rel="stylesheet" href="./assets/linux-polish.css">` + nl + "</head>");
}

fs.writeFileSync(file, html, "utf8");
NODE
fi

cat > codex-linux.sh <<"LAUNCHER"
#!/bin/sh
APP_DIR="$(cd "$(dirname "$0")" && pwd)"
export PATH="${APP_DIR}/resources:${APP_DIR}/resources/bin:${PATH}"
export CODEX_CLI_PATH="${APP_DIR}/resources/bin/codex"

if [ ! -f "${CODEX_CLI_PATH}" ]; then
  echo "codex binary not found at ${CODEX_CLI_PATH}" >&2
  exit 1
fi

if command -v electron >/dev/null 2>&1; then
  exec electron "${APP_DIR}" "$@"
fi

echo "Electron not installed. Run CLI: ${CODEX_CLI_PATH}" >&2
exit 1
LAUNCHER
chmod +x codex-linux.sh

# Ensure bind-mounted outputs are writable by the invoking user on the host.
chown -R "${HOST_UID}:${HOST_GID}" /output 2>/dev/null || true
'

# Fix ownership for rootless Docker compatibility
sudo chown -R "$(id -u):$(id -g)" "{{env.WORKDIR}}/docker-output" 2>/dev/null || true
"""

[tasks."codex:prepare-bundle"]
description = "Copy built bundle to stable cache path"
depends = ["codex:docker-run"]
run = """
set -euo pipefail
docker_output_dir="{{env.WORKDIR}}/docker-output"
bundle_dir="$docker_output_dir/codex-linux"

if [ -d "$docker_output_dir/work/app_unpacked" ]; then
  rm -rf "$bundle_dir"
  cp -a "$docker_output_dir/work/app_unpacked" "$bundle_dir"
fi

if [ ! -d "$bundle_dir" ]; then
  echo "âŒ Missing app bundle after Docker build" >&2
  exit 1
fi
"""

[tasks."codex:rebuild-native"]
description = "Rebuild native modules against host Electron ABI"
depends = ["codex:prepare-bundle"]
run = """
set -euo pipefail
if [ "${CODEX_SKIP_REBUILD_NATIVE:-0}" = "1" ]; then
  echo "Skipping native module rebuild (CODEX_SKIP_REBUILD_NATIVE=1)"
  exit 0
fi

app_dir="{{env.WORKDIR}}/docker-output/codex-linux"
native_build_dir="{{env.WORKDIR}}/native-build-host"

if ! command -v node >/dev/null 2>&1 || ! command -v npm >/dev/null 2>&1; then
  echo "âŒ node and npm are required on host for native module rebuild" >&2
  exit 1
fi

pushd "$app_dir" >/dev/null
package_electron_version=$(node -p "require('./package.json').devDependencies?.electron || ''" 2>/dev/null || true)
package_electron_version="${package_electron_version#^}"

host_electron_version=""
if command -v electron >/dev/null 2>&1; then
  host_electron_version=$(electron --version 2>/dev/null || true)
  host_electron_version="${host_electron_version#v}"
  host_electron_version="${host_electron_version#^}"
fi

electron_version="${host_electron_version:-${package_electron_version}}"
if [ -z "$electron_version" ]; then
  echo "âŒ Unable to determine Electron version for native rebuild" >&2
  exit 1
fi

sqlite_version=$(node -p "require('./node_modules/better-sqlite3/package.json').version" 2>/dev/null || echo "12.5.0")
pty_version=$(node -p "require('./node_modules/node-pty/package.json').version" 2>/dev/null || echo "1.1.0")
popd >/dev/null

rm -rf "$native_build_dir"
mkdir -p "$native_build_dir"
pushd "$native_build_dir" >/dev/null
npm init -y >/dev/null 2>&1

npm_config_runtime=electron \
npm_config_target="$electron_version" \
npm_config_disturl=https://electronjs.org/headers \
npm install --force --no-save "better-sqlite3@${sqlite_version}" "node-pty@${pty_version}" >/dev/null

popd >/dev/null

mkdir -p "$app_dir/node_modules/better-sqlite3/build/Release"
mkdir -p "$app_dir/node_modules/node-pty/build/Release"
cp -f "$native_build_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node" "$app_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node"
cp -f "$native_build_dir/node_modules/node-pty/build/Release/pty.node" "$app_dir/node_modules/node-pty/build/Release/pty.node"

file "$app_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node" | grep -q ELF
file "$app_dir/node_modules/node-pty/build/Release/pty.node" | grep -q ELF

if ldd "$app_dir/node_modules/better-sqlite3/build/Release/better_sqlite3.node" | grep -q libnode; then
  echo "âŒ better-sqlite3 still links libnode" >&2
  exit 1
fi

if ldd "$app_dir/node_modules/node-pty/build/Release/pty.node" | grep -q libnode; then
  echo "âŒ node-pty still links libnode" >&2
  exit 1
fi
"""

[tasks."codex:package-appimage"]
description = "Package Codex.AppImage into repo root"
depends = ["codex:rebuild-native"]
run = """
set -euo pipefail
bundle_dir="{{env.WORKDIR}}/docker-output/codex-linux"
output_path="{{config_root}}/Codex.AppImage"

if [ ! -d "$bundle_dir" ]; then
  echo "âŒ App bundle not found at $bundle_dir" >&2
  exit 1
fi

tempdir=$(mktemp -d)
appdir="$tempdir/Codex.AppDir"
mkdir -p "$appdir/usr/share/codex" "$appdir/usr/bin"

cp -a "$bundle_dir"/. "$appdir/usr/share/codex/"
cp -f "$appdir/usr/share/codex/resources/bin/codex" "$appdir/usr/bin/codex"
chmod +x "$appdir/usr/bin/codex"

cat > "$appdir/AppRun" <<"EOF"
#!/bin/sh
HERE="$(dirname "$(readlink -f "$0")")"
APP_DIR="${HERE}/usr/share/codex"
export PATH="${APP_DIR}/resources:${APP_DIR}/resources/bin:${PATH}"
export CODEX_CLI_PATH="${APP_DIR}/resources/bin/codex"

if [ "${1:-}" = "--cli" ]; then
  shift
  exec "${CODEX_CLI_PATH}" "$@"
fi

if command -v electron >/dev/null 2>&1; then
  exec electron "${APP_DIR}" "$@"
fi

echo "Electron not found on host."
echo "Run CLI mode with: ./Codex.AppImage --cli --help"
exit 1
EOF
chmod +x "$appdir/AppRun"

cat > "$appdir/codex.desktop" <<"EOF"
[Desktop Entry]
Name=Codex
GenericName=AI Coding Assistant
Comment=OpenAI Codex - AI-powered coding assistant
Exec=AppRun
Icon=codex
Terminal=false
Type=Application
Categories=Development;IDE;TextEditor;
Keywords=codex;ai;code;editor;openai;
EOF

icon_src=$(ls "$appdir"/usr/share/codex/webview/assets/app-*.png 2>/dev/null | head -1 || true)
if [ -z "$icon_src" ]; then
  icon_src=$(ls "$appdir"/usr/share/codex/webview/assets/logo-*.png 2>/dev/null | head -1 || true)
fi
if [ -z "$icon_src" ]; then
  echo "âŒ Could not find Codex icon PNG in bundle" >&2
  exit 1
fi
cp -f "$icon_src" "$appdir/codex.png"

tools_dir="{{env.WORKDIR}}/tools"
appimagetool="$tools_dir/appimagetool.AppImage"
mkdir -p "$tools_dir"

if [ ! -x "$appimagetool" ]; then
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL -o "$appimagetool" "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
  else
    wget -qO "$appimagetool" "https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage"
  fi
  chmod +x "$appimagetool"
fi

rm -f "$output_path"
ARCH=x86_64 APPIMAGE_EXTRACT_AND_RUN=1 "$appimagetool" "$appdir" "$output_path" >/dev/null
chmod +x "$output_path"
rm -rf "$tempdir"
"""

[tasks."codex:versions"]
description = "Update versions.json from generated AppImage"
depends = ["codex:package-appimage"]
run = """
set -euo pipefail
appimage_path="{{config_root}}/Codex.AppImage"
versions_file="{{config_root}}/versions.json"

if [ ! -x "$appimage_path" ]; then
  echo "âŒ AppImage not found at $appimage_path" >&2
  exit 1
fi

cli_version_output="$($appimage_path --cli --version)"
cli_version="$(awk '{print $2}' <<<"$cli_version_output")"
if [ -z "$cli_version" ]; then
  echo "âŒ Failed to parse CLI version" >&2
  exit 1
fi

tmp=$(mktemp -d)
cp "$appimage_path" "$tmp/Codex.AppImage"
(cd "$tmp" && ./Codex.AppImage --appimage-extract >/dev/null 2>&1)
app_version="$(node -p "require('$tmp/squashfs-root/usr/share/codex/package.json').version" 2>/dev/null || true)"
rm -rf "$tmp"

if [ -z "$app_version" ]; then
  echo "âŒ Failed to parse app version" >&2
  exit 1
fi

cat > "$versions_file" <<EOF
{
  "app": "$app_version",
  "cli": "$cli_version"
}
EOF
"""

[tasks."codex:ui:extract"]
description = "Extract current AppImage assets for UI analysis"
run = """
set -euo pipefail
appimage_path="{{config_root}}/Codex.AppImage"
inspect_dir="{{config_root}}/.ui-inspect"

if [ ! -x "$appimage_path" ]; then
  echo "âŒ AppImage not found at $appimage_path (run: mise run codex:build)" >&2
  exit 1
fi

rm -rf "$inspect_dir"
mkdir -p "$inspect_dir"
cp "$appimage_path" "$inspect_dir/Codex.AppImage"
(cd "$inspect_dir" && ./Codex.AppImage --appimage-extract >/dev/null 2>&1)

css_file=$(ls "$inspect_dir"/squashfs-root/usr/share/codex/webview/assets/index-*.css 2>/dev/null | head -1 || true)
if [ -z "$css_file" ]; then
  echo "âŒ Could not locate bundled index CSS in extracted AppImage" >&2
  exit 1
fi

cp "$css_file" "$inspect_dir/index.css"
if [ -f "$inspect_dir/squashfs-root/usr/share/codex/webview/assets/linux-polish.css" ]; then
  cp "$inspect_dir/squashfs-root/usr/share/codex/webview/assets/linux-polish.css" "$inspect_dir/linux-polish.css"
fi

echo "UI inspect assets ready at: $inspect_dir"
"""

[tasks."codex:ui:sync-polish"]
description = "Regenerate linux-polish.css in extracted UI bundle"
run = """
set -euo pipefail
inspect_dir="{{config_root}}/.ui-inspect"
assets_dir="$inspect_dir/squashfs-root/usr/share/codex/webview/assets"
index_html="$inspect_dir/squashfs-root/usr/share/codex/webview/index.html"
candidate_file="{{config_root}}/ui-design-overrides.candidate.json"
pinned_file="{{config_root}}/ui-design-overrides.json"

if [ ! -d "$assets_dir" ]; then
  mise run codex:ui:extract >/dev/null
fi

css_file=$(ls "$assets_dir"/index-*.css 2>/dev/null | head -1 || true)
if [ -z "$css_file" ]; then
  echo "âŒ Could not locate bundled index CSS in extracted AppImage" >&2
  exit 1
fi

override_file="${UI_OVERRIDES_FILE:-}"
if [ -z "$override_file" ]; then
  if [ -s "$candidate_file" ]; then
    override_file="$candidate_file"
  elif [ -s "$pinned_file" ]; then
    override_file="$pinned_file"
  fi
fi

CSS_FILE="$css_file" OVERRIDE_FILE="$override_file" OUT_FILE="$assets_dir/linux-polish.css" node - <<'NODE'
const fs = require('fs');

const cssFile = process.env.CSS_FILE;
const overridePath = process.env.OVERRIDE_FILE || '';
const outFile = process.env.OUT_FILE;
const css = fs.readFileSync(cssFile, 'utf8');

let manualTokenOverrides = {};
let manualTitlebarTint = '';
if (overridePath && fs.existsSync(overridePath)) {
  try {
    const parsed = JSON.parse(fs.readFileSync(overridePath, 'utf8'));
    if (parsed && typeof parsed === 'object') {
      if (parsed.token_overrides && typeof parsed.token_overrides === 'object') {
        manualTokenOverrides = parsed.token_overrides;
      }
      if (typeof parsed.codex_titlebar_tint === 'string' && parsed.codex_titlebar_tint.trim()) {
        manualTitlebarTint = parsed.codex_titlebar_tint.trim();
      }
    }
  } catch {
    manualTokenOverrides = {};
    manualTitlebarTint = '';
  }
}

function readThemeVar(selector, key) {
  const token = selector + '{';
  let pos = 0;
  while (true) {
    const start = css.indexOf(token, pos);
    if (start === -1) return '';
    let i = start + token.length;
    let depth = 1;
    while (i < css.length && depth > 0) {
      const ch = css[i];
      if (ch === '{') depth += 1;
      else if (ch === '}') depth -= 1;
      i += 1;
    }
    const block = css.slice(start + token.length, i - 1);
    for (const decl of block.split(';')) {
      const idx = decl.indexOf(':');
      if (idx === -1) continue;
      const declKey = decl.slice(0, idx).trim();
      const value = decl.slice(idx + 1).trim();
      if (declKey === key) return value;
    }
    pos = i;
  }
}

const semanticDefaults = {
  '--color-background-surface': readThemeVar('.electron-light', '--color-background-surface') || 'var(--gray-0)',
  '--color-background-surface-under': readThemeVar('.electron-light', '--color-background-surface-under') || 'var(--gray-0)',
  '--color-background-elevated-primary': readThemeVar('.electron-light', '--color-background-elevated-primary') || 'color-mix(in oklab, var(--gray-0) 88%, transparent)',
  '--color-background-elevated-secondary': readThemeVar('.electron-light', '--color-background-elevated-secondary') || 'color-mix(in oklab, var(--gray-1000) 2%, transparent)',
  '--color-border': readThemeVar('.electron-light', '--color-border') || 'color-mix(in oklab, var(--gray-1000) 8%, transparent)',
  '--color-text-foreground': readThemeVar('.electron-light', '--color-text-foreground') || 'var(--gray-1000)',
  '--color-text-foreground-secondary': readThemeVar('.electron-light', '--color-text-foreground-secondary') || 'color-mix(in oklab, var(--gray-1000) 70%, transparent)',
  '--color-icon-primary': readThemeVar('.electron-light', '--color-icon-primary') || 'var(--gray-1000)',
};

const lines = [];
lines.push('/* Auto-generated Linux polish: conservative semantic overrides */');
lines.push('.electron-light,');
lines.push('.electron-dark {');
lines.push('  color-scheme: light;');
for (const [key, value] of Object.entries(semanticDefaults)) {
  lines.push(`  ${key}: ${value};`);
}
for (const [key, value] of Object.entries(manualTokenOverrides)) {
  if (typeof key !== 'string' || typeof value !== 'string') continue;
  if (!key.startsWith('--')) continue;
  lines.push(`  ${key}: ${value};`);
}
const titlebarTint = manualTitlebarTint || 'color-mix(in oklab, var(--blue-100) 42%, transparent)';
lines.push(`  --codex-titlebar-tint: ${titlebarTint};`);
lines.push('}');
lines.push('');
lines.push('/* Keep structure untouched; token-only overrides for stability */');
lines.push('.electron-light aside,');
lines.push('.electron-dark aside,');
lines.push('.electron-light [role="navigation"],');
lines.push('.electron-dark [role="navigation"] {');
lines.push('  box-shadow: none !important;');
lines.push('  background-color: var(--color-background-surface) !important;');
lines.push('  opacity: 1 !important;');
lines.push('  filter: none !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light nav[role="navigation"],');
lines.push('.electron-dark nav[role="navigation"] {');
lines.push('  mask-image: none !important;');
lines.push('  -webkit-mask-image: none !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light nav[role="navigation"] button.opacity-75:not(:disabled),');
lines.push('.electron-dark nav[role="navigation"] button.opacity-75:not(:disabled),');
lines.push('.electron-light nav[role="navigation"] [role="button"].opacity-75:not([aria-disabled="true"]),');
lines.push('.electron-dark nav[role="navigation"] [role="button"].opacity-75:not([aria-disabled="true"]) {');
lines.push('  opacity: 1 !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light nav[role="navigation"] [class*="electron:opacity-75"],');
lines.push('.electron-dark nav[role="navigation"] [class*="electron:opacity-75"],');
lines.push('.electron-light aside [class*="electron:opacity-75"],');
lines.push('.electron-dark aside [class*="electron:opacity-75"],');
lines.push('.electron-light nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-light nav[role="navigation"] .text-token-input-placeholder-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-input-placeholder-foreground {');
lines.push('  opacity: 1 !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light aside .text-token-description-foreground,');
lines.push('.electron-dark aside .text-token-description-foreground,');
lines.push('.electron-light aside .text-token-input-placeholder-foreground,');
lines.push('.electron-dark aside .text-token-input-placeholder-foreground,');
lines.push('.electron-light nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-description-foreground,');
lines.push('.electron-light nav[role="navigation"] .text-token-input-placeholder-foreground,');
lines.push('.electron-dark nav[role="navigation"] .text-token-input-placeholder-foreground {');
lines.push('  color: var(--color-text-foreground-secondary) !important;');
lines.push('  opacity: 1 !important;');
lines.push('}');
lines.push('');
lines.push('.electron-light .app-header-tint,');
lines.push('.electron-dark .app-header-tint {');
lines.push('  box-shadow: none !important;');
lines.push('}');
lines.push('');
lines.push('/* Hide debug-only navigation entries in production builds */');
lines.push('nav[role="navigation"] [aria-label="Debug"],');
lines.push('nav[role="navigation"] [title="Debug"],');
lines.push('nav[role="navigation"] a[href$="/debug"],');
lines.push('nav[role="navigation"] a[href*="/debug?"],');
lines.push('aside [aria-label="Debug"],');
lines.push('aside [title="Debug"],');
lines.push('aside a[href$="/debug"],');
lines.push('aside a[href*="/debug?"] {');
lines.push('  display: none !important;');
lines.push('}');

const nl = String.fromCharCode(10);
fs.writeFileSync(outFile, lines.join(nl) + nl, 'utf8');
NODE

INDEX_HTML="$index_html" node - <<'NODE'
const fs = require('fs');
const file = process.env.INDEX_HTML;
let html = fs.readFileSync(file, 'utf8');
const nl = String.fromCharCode(10);

html = html
  .split(nl)
  .filter((line) => !line.includes('linux-polish.css'))
  .join(nl);

if (!html.includes('linux-polish.css')) {
  html = html.replace('</head>', '    <link rel="stylesheet" href="./assets/linux-polish.css">' + nl + '</head>');
}

fs.writeFileSync(file, html, 'utf8');
NODE

cp "$css_file" "$inspect_dir/index.css"
cp "$assets_dir/linux-polish.css" "$inspect_dir/linux-polish.css"

echo "Synced linux polish in extracted bundle: $inspect_dir"
"""

[tasks."codex:ui:capture"]
description = "Run extracted app and capture live UI"
depends = ["codex:ui:sync-polish"]
run = """
set -euo pipefail
inspect_dir="{{config_root}}/.ui-inspect"
app_run="$inspect_dir/squashfs-root/AppRun"

if ! command -v agent-browser >/dev/null 2>&1; then
  echo "âŒ agent-browser not found" >&2
  exit 1
fi

if [ ! -x "$app_run" ]; then
  echo "âŒ Missing extracted AppRun at $app_run" >&2
  echo "Run: mise run codex:ui:extract" >&2
  exit 1
fi

# Kill any stale Codex/Electron from previous runs
pkill -f "AppRun.*remote-debugging-port" 2>/dev/null || true
if command -v xdotool >/dev/null 2>&1; then
  for w in $(xdotool search --name "Open project" 2>/dev/null || true); do
    xdotool windowclose "$w" 2>/dev/null || true
  done
fi
sleep 0.5

debug_port=$(node -e "const net=require('net');const s=net.createServer();s.listen(0,'127.0.0.1',()=>{process.stdout.write(String(s.address().port));s.close();});")

"$app_run" --remote-debugging-port="$debug_port" --remote-debugging-address=127.0.0.1 >/tmp/codex-ui-capture.log 2>&1 &
app_pid=$!

cleanup() {
  kill "$app_pid" >/dev/null 2>&1 || true
  sleep 0.3
  if command -v xdotool >/dev/null 2>&1; then
    for w in $(xdotool search --name "Open project" 2>/dev/null || true); do
      xdotool windowclose "$w" 2>/dev/null || true
    done
  fi
}
trap cleanup EXIT

ready=0
for _ in $(seq 1 80); do
  if curl -fsS "http://127.0.0.1:$debug_port/json/version" >/dev/null 2>&1; then
    ready=1
    break
  fi
  sleep 0.1
done

if [ "$ready" -ne 1 ]; then
  echo "âŒ Timed out waiting for debug port $debug_port" >&2
  exit 1
fi

sleep 1

agent-browser --cdp "$debug_port" snapshot -i --json > "$inspect_dir/codex-snapshot.json"
agent-browser --cdp "$debug_port" get title > "$inspect_dir/codex-title.txt"
agent-browser --cdp "$debug_port" screenshot --full --json > "$inspect_dir/codex-screenshot-meta.json"

node - <<'NODE'
const fs = require('fs');
const path = require('path');
const inspectDir = '{{config_root}}/.ui-inspect';
const meta = JSON.parse(fs.readFileSync(path.join(inspectDir, 'codex-screenshot-meta.json'), 'utf8'));
const src = meta && meta.data && meta.data.path;
if (!src || !fs.existsSync(src)) {
  throw new Error('screenshot path missing in codex-screenshot-meta.json');
}
fs.copyFileSync(src, path.join(inspectDir, 'codex-current.png'));
NODE

echo "Captured UI snapshot at $inspect_dir/codex-current.png"
"""

[tasks."codex:ui:design"]
description = "Use Claude CLI to generate candidate UI overrides"
depends = ["codex:ui:capture"]
run = """
set -euo pipefail
inspect_dir="{{config_root}}/.ui-inspect"
candidate_file="{{config_root}}/ui-design-overrides.candidate.json"
summary_file="$inspect_dir/theme-summary.json"
raw_file="$inspect_dir/claude-ui-response.json"
claude_model="${CLAUDE_MODEL:-claude-opus-4-6}"

if ! command -v claude >/dev/null 2>&1; then
  echo "âŒ claude CLI not found" >&2
  exit 1
fi

node - <<'NODE'
const fs = require('fs');
const path = require('path');

const inspectDir = '{{config_root}}/.ui-inspect';
const cssFile = path.join(inspectDir, 'index.css');
const outFile = path.join(inspectDir, 'theme-summary.json');
const candidateFile = '{{config_root}}/ui-design-overrides.candidate.json';
const pinnedFile = '{{config_root}}/ui-design-overrides.json';
const css = fs.readFileSync(cssFile, 'utf8');

let currentOverrides = {};
const sourceFile = fs.existsSync(candidateFile) ? candidateFile : pinnedFile;
if (fs.existsSync(sourceFile)) {
  try {
    const parsed = JSON.parse(fs.readFileSync(sourceFile, 'utf8'));
    if (parsed && parsed.token_overrides && typeof parsed.token_overrides === 'object') {
      currentOverrides = parsed.token_overrides;
    }
  } catch {
    currentOverrides = {};
  }
}

function collectThemeVars(selector) {
  const vars = {};
  const token = selector + '{';
  let pos = 0;
  while (true) {
    const start = css.indexOf(token, pos);
    if (start === -1) break;
    let i = start + token.length;
    let depth = 1;
    while (i < css.length && depth > 0) {
      const ch = css[i];
      if (ch === '{') depth += 1;
      else if (ch === '}') depth -= 1;
      i += 1;
    }
    const block = css.slice(start + token.length, i - 1);
    for (const decl of block.split(';')) {
      const idx = decl.indexOf(':');
      if (idx === -1) continue;
      const key = decl.slice(0, idx).trim();
      const value = decl.slice(idx + 1).trim();
      if (!key.startsWith('--')) continue;
      vars[key] = value;
    }
    pos = i;
  }
  return vars;
}

const light = collectThemeVars('.electron-light');
const dark = collectThemeVars('.electron-dark');
const focusKeys = [
  '--color-background-surface',
  '--color-background-surface-under',
  '--color-background-elevated-primary',
  '--color-background-elevated-primary-opaque',
  '--color-background-elevated-secondary',
  '--color-background-elevated-secondary-opaque',
  '--color-border',
  '--color-border-light',
  '--color-border-heavy',
  '--color-border-focus',
  '--color-text-foreground',
  '--color-text-foreground-secondary',
  '--color-text-foreground-tertiary',
  '--color-text-accent',
  '--color-text-button-secondary',
  '--color-icon-primary',
  '--color-icon-secondary',
  '--color-icon-tertiary',
  '--color-background-button-secondary',
  '--color-background-accent',
];

const summary = {
  focusTokens: focusKeys.map((key) => ({
    key,
    light: light[key] || null,
    dark: dark[key] || null,
    currentOverride: Object.prototype.hasOwnProperty.call(currentOverrides, key) ? currentOverrides[key] : null,
  })),
};

const nl = String.fromCharCode(10);
fs.writeFileSync(outFile, JSON.stringify(summary, null, 2) + nl, 'utf8');
NODE

schema='{"type":"object","properties":{"codex_titlebar_tint":{"type":"string"},"token_overrides":{"type":"object","additionalProperties":{"type":"string"}},"notes":{"type":"array","items":{"type":"string"}}},"required":["codex_titlebar_tint","token_overrides","notes"]}'

prompt=$(cat <<PROMPT
Design Linux UI overrides for Codex from this focused token summary:

$(cat "$summary_file")

Return stable, conservative overrides to make Linux look closer to a clean/light macOS style.
Constraints:
- Max 20 token_overrides entries.
- Use only semantic tokens (prefer --color-background-*, --color-text-*, --color-border-*).
- Avoid brittle selectors/components.
- Keep contrast readable and avoid flashy styling.
- Prioritize sidebar legibility and avoid washed-out thread labels.
PROMPT
)

run_claude() {
  local model_name="$1"
  claude -p --model "$model_name" --permission-mode dontAsk --output-format json --json-schema "$schema" "$prompt" > "$raw_file"
}

if ! run_claude "$claude_model"; then
  if [ "$claude_model" = "opus" ]; then
    exit 1
  fi
  echo "âš ï¸ Model '$claude_model' unavailable, retrying with --model opus" >&2
  run_claude "opus"
fi

node - <<'NODE'
const fs = require('fs');
const rawFile = '{{config_root}}/.ui-inspect/claude-ui-response.json';
const outFile = '{{config_root}}/ui-design-overrides.candidate.json';
const raw = JSON.parse(fs.readFileSync(rawFile, 'utf8'));
const parsed = raw.structured_output || raw;
if (!parsed || typeof parsed !== 'object') throw new Error('Invalid JSON root');
if (typeof parsed.codex_titlebar_tint !== 'string') throw new Error('Missing codex_titlebar_tint');
if (!parsed.token_overrides || typeof parsed.token_overrides !== 'object') throw new Error('Missing token_overrides');
const entries = Object.entries(parsed.token_overrides);
if (entries.length > 20) throw new Error('Too many token overrides (max 20)');
for (const [k, v] of entries) {
  if (!k.startsWith('--')) throw new Error(`Invalid token key: ${k}`);
  if (typeof v !== 'string') throw new Error(`Invalid token value for ${k}`);
}
const nl = String.fromCharCode(10);
fs.writeFileSync(outFile, JSON.stringify(parsed, null, 2) + nl, 'utf8');
console.log('ui-design-overrides.candidate.json validated');
NODE
"""

[tasks."codex:ui:pin"]
description = "Promote candidate overrides to pinned overrides"
run = """
set -euo pipefail
candidate_file="{{config_root}}/ui-design-overrides.candidate.json"
pinned_file="{{config_root}}/ui-design-overrides.json"

if [ ! -s "$candidate_file" ]; then
  echo "âŒ Candidate overrides missing: $candidate_file" >&2
  exit 1
fi

cp "$candidate_file" "$pinned_file"
echo "Pinned overrides updated: $pinned_file"
"""

[tasks."codex:ui:iterate"]
description = "Fast loop: apply overrides and capture screenshot"
depends = ["codex:ui:capture"]
run = """
echo "Updated screenshot: .ui-inspect/codex-current.png"
"""

[tasks."codex:ui:loop"]
description = "Generate candidate with Claude and print next steps"
depends = ["codex:ui:design"]
run = """
echo "UI candidate generated: ui-design-overrides.candidate.json"
echo "Review then run:"
echo "  mise run codex:ui:pin"
echo "  mise run codex:ui:iterate"
echo "Build AppImage only when happy with result:"
echo "  mise run codex:build"
"""

[tasks."codex:release"]
description = "Build AppImage and publish/update GitHub release"
depends = ["codex:build"]
run = """
set -euo pipefail
appimage_path="{{config_root}}/Codex.AppImage"
versions_file="{{config_root}}/versions.json"

if ! command -v gh >/dev/null 2>&1; then
  echo "âŒ GitHub CLI (gh) not found" >&2
  exit 1
fi

gh auth status >/dev/null 2>&1 || {
  echo "âŒ gh is not authenticated. Run: gh auth login" >&2
  exit 1
}

app_version="$(jq -r '.app' "$versions_file")"
cli_version="$(jq -r '.cli' "$versions_file")"

if [ -z "$app_version" ] || [ "$app_version" = "null" ]; then
  echo "âŒ Invalid app version in $versions_file" >&2
  exit 1
fi

tag="v$app_version"
title="Codex AppImage $app_version"
notes="Automated AppImage release for Codex app $app_version (CLI $cli_version)."

if gh release view "$tag" >/dev/null 2>&1; then
  gh release upload "$tag" "$appimage_path" --clobber
  gh release edit "$tag" --title "$title" --notes "$notes"
else
  gh release create "$tag" "$appimage_path" --title "$title" --notes "$notes"
fi
"""

[tasks."codex:cleanup"]
description = "Remove temporary build cache directories"
run = "rm -rf {{env.WORKDIR}}/docker-output {{env.WORKDIR}}/native-build-host"

[tasks."codex:build"]
description = "Build Codex AppImage end-to-end"
depends = ["codex:versions"]
run = """
echo ""
echo "âœ… Build complete!"
echo "ðŸ“¦ AppImage: {{config_root}}/Codex.AppImage"
echo "ðŸ“„ Versions: {{config_root}}/versions.json"
echo "Run GUI: {{config_root}}/Codex.AppImage"
echo "Run CLI: {{config_root}}/Codex.AppImage --cli --help"
"""

# Windows installer builds are handled by GitHub Actions:
# - .github/workflows/build-release.yml

[settings]
jobs = 4
unix_default_file_shell_args = "bash"
unix_default_inline_shell_args = "bash -lc"
