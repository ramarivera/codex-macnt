# Windows x64 Electron app build for Codex
#
# Uses a pre-compiled codex.exe from dist/windows-x64/ (cross-compiled locally
# via `mise run codex:win:compile`). This workflow only handles:
#   1. DMG/ASAR extraction (Linux runner â€” fast, ~2 min)
#   2. Native module rebuild + Electron packaging (Windows runner)
#
# No Rust compilation happens here â€” that's done locally and committed.

name: Build Codex Windows x64

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"
    paths:
      - "dist/windows-x64/codex.exe"
      - ".github/workflows/build-windows.yml"

env:
  CODEX_DMG_URL: "https://persistent.oaistatic.com/codex-app-prod/Codex.dmg"

jobs:
  # Stage 1: Extract app resources from DMG (Linux â€” needs dmg2img + 7z)
  extract:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify codex.exe exists in repo
        run: |
          if [ ! -f dist/windows-x64/codex.exe ]; then
            echo "âŒ dist/windows-x64/codex.exe not found in repo." >&2
            echo "   Run locally: mise run codex:win:compile" >&2
            echo "   Then commit and push dist/windows-x64/codex.exe" >&2
            exit 1
          fi
          file dist/windows-x64/codex.exe

      - name: Install extraction tools
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full dmg2img icnsutils
          npm install -g @electron/asar
          # ImageMagick for icon conversion
          if ! command -v magick &> /dev/null; then
            sudo apt-get install -y imagemagick
          fi

      - name: Download and extract DMG
        run: |
          curl -L --fail -o Codex.dmg "$CODEX_DMG_URL"
          dmg2img Codex.dmg Codex.img
          mkdir -p extracted
          7z x Codex.img -oextracted/ -y >/dev/null || true

      - name: Extract and convert Codex icon from DMG
        run: |
          # Look for the .icns icon file in the extracted app bundle
          ICNS_PATH=$(find extracted -name "*.icns" -type f | head -1)
          if [ -n "$ICNS_PATH" ]; then
            echo "Found icon: $ICNS_PATH"
            cp "$ICNS_PATH" codex-icon.icns
            ls -lh codex-icon.icns
            
            # Convert .icns to .ico for Windows - resize to 256x256 max for Windows compatibility
            if command -v icns2png &> /dev/null; then
              echo "Converting .icns to .ico using icns2png..."
              icns2png -x codex-icon.icns
              # Find 256x256 or smaller icon (Windows ICO size limit)
              TARGET_PNG=$(ls codex-icon_*.png 2>/dev/null | grep -E "(256x256|128x128|64x64|32x32)" | head -1)
              if [ -z "$TARGET_PNG" ]; then
                # Fallback to largest if no standard size found
                TARGET_PNG=$(ls -S codex-icon_*.png 2>/dev/null | head -1)
              fi
              if [ -n "$TARGET_PNG" ] && command -v convert &> /dev/null; then
                echo "Using $TARGET_PNG for icon conversion"
                convert "$TARGET_PNG" -resize 256x256 codex-icon.ico
                ls -lh codex-icon.ico
              fi
            elif command -v magick &> /dev/null; then
              echo "Converting .icns to .ico using ImageMagick..."
              # Use first frame and resize to 256x256 max for Windows
              magick codex-icon.icns[0] -resize 256x256 codex-icon.ico
              ls -lh codex-icon.ico
            else
              echo "âš ï¸  No icon conversion tools available - will try to use .icns directly or skip icon"
            fi
          else
            echo "âš ï¸  No .icns file found in DMG - installer will use default Electron icon"
            echo "    Looked in: extracted/"
            find extracted -type f -name "*.icns" 2>/dev/null || echo "    (no .icns files found)"
          fi

      - name: Extract ASAR
        run: |
          ASAR_PATH=$(find extracted -name app.asar -type f | head -1)
          if [ -z "$ASAR_PATH" ]; then
            echo "Could not locate app.asar" >&2
            exit 1
          fi
          asar extract "$ASAR_PATH" app_unpacked/

      - name: Clean macOS-only files and install codex.exe from repo
        run: |
          cd app_unpacked
          rm -f native/sparkle.node
          rm -rf node_modules/electron-liquid-glass

          mkdir -p resources resources/bin
          cp "$GITHUB_WORKSPACE/dist/windows-x64/codex.exe" resources/codex.exe
          cp resources/codex.exe resources/bin/codex.exe

      - name: Include icon in app bundle if available
        run: |
          # Prefer .ico file (Windows native format), fallback to .icns
          if [ -f "codex-icon.ico" ]; then
            cp codex-icon.ico app_unpacked/resources/codex-icon.ico
            echo "âœ… Windows .ico icon included in app bundle"
          elif [ -f "codex-icon.icns" ]; then
            cp codex-icon.icns app_unpacked/resources/codex-icon.icns
            echo "âœ… macOS .icns icon included in app bundle (may not work on Windows)"
          fi

      - name: Verify .vite directory exists (critical for Electron main entry)
        run: |
          if [ ! -d "app_unpacked/.vite" ]; then
            echo "âŒ .vite directory missing from extracted ASAR!" >&2
            exit 1
          fi
          if [ ! -f "app_unpacked/.vite/build/main.js" ]; then
            echo "âŒ .vite/build/main.js missing!" >&2
            exit 1
          fi
          echo "âœ… .vite directory verified"
          ls -la app_unpacked/.vite/build/

      - name: Tar app bundle (preserve hidden .vite directory)
        run: |
          echo "Creating tar archive of app_unpacked..."
          tar -czf app-unpacked.tar.gz app_unpacked/
          ls -lh app-unpacked.tar.gz

      - name: Upload extracted app bundle (internal, deleted after packaging)
        uses: actions/upload-artifact@v4
        with:
          name: app-unpacked
          path: app-unpacked.tar.gz
          retention-days: 1

  # Stage 2: Native modules + packaging on Windows
  package:
    needs: extract
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Download extracted app bundle
        uses: actions/download-artifact@v4
        with:
          name: app-unpacked

      - name: Extract app bundle
        shell: bash
        run: |
          echo "Extracting app bundle from tar archive..."
          tar -xzf app-unpacked.tar.gz
          ls -la app_unpacked/
          echo "Checking .vite directory..."
          ls -la app_unpacked/.vite/

      - name: Determine Electron version
        id: electron-version
        shell: bash
        run: |
          cd app_unpacked
          ver=$(node -p "require('./package.json').devDependencies?.electron || ''" 2>/dev/null || true)
          ver="${ver#^}"
          if [ -z "$ver" ]; then
            echo "Could not determine Electron version from package.json" >&2
            exit 1
          fi
          echo "version=$ver" >> "$GITHUB_OUTPUT"

      - name: Rebuild native modules for Windows Electron
        shell: bash
        run: |
          electron_ver="${{ steps.electron-version.outputs.version }}"

          # The ASAR-extracted node_modules only have macOS prebuilt binaries
          # and are missing source/deps needed for compilation (e.g.
          # better-sqlite3/deps/common.gypi). Reinstall from npm to get full
          # source trees, then rebuild for Windows Electron ABI.

          # Get versions from the extracted bundle
          sqlite_ver=$(node -p "require('./app_unpacked/node_modules/better-sqlite3/package.json').version")
          pty_ver=$(node -p "require('./app_unpacked/node_modules/node-pty/package.json').version")
          echo "better-sqlite3=$sqlite_ver  node-pty=$pty_ver  electron=$electron_ver"

          # Install fresh copies with full source (--ignore-scripts skips native build)
          mkdir -p _native_src
          cd _native_src
          npm init -y
          npm install "better-sqlite3@$sqlite_ver" "node-pty@$pty_ver" --ignore-scripts
          cd ..

          # Replace extracted modules with fresh source trees
          rm -rf app_unpacked/node_modules/better-sqlite3
          rm -rf app_unpacked/node_modules/node-pty
          cp -r _native_src/node_modules/better-sqlite3 app_unpacked/node_modules/
          cp -r _native_src/node_modules/node-pty app_unpacked/node_modules/
          rm -rf _native_src

          # Install @electron/rebuild globally (can't npm install inside
          # app_unpacked â€” its package.json has workspace:* references)
          npm install -g @electron/rebuild

          # Rebuild against Windows Electron ABI
          electron-rebuild \
            --version "$electron_ver" \
            --arch x64 \
            --module-dir ./app_unpacked \
            --only better-sqlite3,node-pty \
            --build-from-source

          # Debug: show what was built
          echo "=== better-sqlite3 ==="
          find app_unpacked/node_modules/better-sqlite3/build -name "*.node" 2>/dev/null || echo "no .node files found"
          echo "=== node-pty ==="
          find app_unpacked/node_modules/node-pty/build -name "*.node" -o -name "*.dll" -o -name "*.exe" 2>/dev/null || echo "no .node files found"

      - name: Download and assemble Electron distribution
        shell: bash
        run: |
          electron_ver="${{ steps.electron-version.outputs.version }}"
          echo "Downloading Electron v${electron_ver} win32-x64..."
          curl -sL --fail -o electron.zip \
            "https://github.com/electron/electron/releases/download/v${electron_ver}/electron-v${electron_ver}-win32-x64.zip"

          mkdir -p electron-dist
          unzip -q electron.zip -d electron-dist

          # Replace default app with our extracted app bundle
          rm -f electron-dist/resources/default_app.asar
          mv app_unpacked electron-dist/resources/app

          # Rename electron.exe to Codex.exe
          mv electron-dist/electron.exe electron-dist/Codex.exe

          echo "=== Electron distribution assembled ==="
          ls -lh electron-dist/Codex.exe
          ls electron-dist/resources/app/package.json

          # Verify critical .vite directory is present
          if [ ! -d "electron-dist/resources/app/.vite" ]; then
            echo "âŒ .vite directory missing from final package!" >&2
            echo "   Contents of resources/app:" >&2
            ls -la electron-dist/resources/app/ >&2
            exit 1
          fi
          echo "âœ… .vite directory present in final package"

      - name: Verify native modules are PE binaries
        shell: bash
        run: |
          APP=electron-dist/resources/app

          echo "=== Checking better-sqlite3 ==="
          sqlite_node=$(find "$APP/node_modules/better-sqlite3" -name "better_sqlite3.node" | head -1)
          if [ -z "$sqlite_node" ]; then
            echo "better_sqlite3.node not found" >&2
            exit 1
          fi
          file "$sqlite_node" | grep -i "PE32"

          echo "=== Checking node-pty ==="
          pty_node=$(find "$APP/node_modules/node-pty" -name "pty.node" | head -1)
          if [ -z "$pty_node" ]; then
            echo "pty.node not found" >&2
            exit 1
          fi
          file "$pty_node" | grep -i "PE32"

          echo "=== Checking Codex.exe (Electron) ==="
          file electron-dist/Codex.exe | grep -i "PE32"

          echo "=== Checking codex CLI ==="
          file "$APP/resources/codex.exe" | grep -i "PE32"

      - name: Get version info
        id: versions
        shell: bash
        run: |
          APP=electron-dist/resources/app
          cli_ver=$("$APP/resources/codex.exe" --version 2>/dev/null | awk '{print $2}' || echo "unknown")
          app_ver=$(node -p "require('./$APP/package.json').version" 2>/dev/null || echo "unknown")
          echo "cli=$cli_ver" >> "$GITHUB_OUTPUT"
          echo "app=$app_ver" >> "$GITHUB_OUTPUT"

      - name: Build NSIS installer
        shell: bash
        run: |
          app_ver="${{ steps.versions.outputs.app }}"
          mv electron-dist codex-windows-x64

          # Check if icon was included - prefer .ico, fallback to .icns
          ICON_DEFINE=""
          if [ -f "codex-windows-x64/resources/app/resources/codex-icon.ico" ]; then
            echo "ðŸŽ¨ Windows .ico icon found in app bundle"
            ICON_DEFINE="-DAPP_ICON=resources\app\resources\codex-icon.ico"
          elif [ -f "codex-windows-x64/resources/app/resources/codex-icon.icns" ]; then
            echo "ðŸŽ¨ macOS .icns icon found in app bundle (may not display correctly)"
            ICON_DEFINE="-DAPP_ICON=resources\app\resources\codex-icon.icns"
          fi

          # NSIS is pre-installed on windows-latest at this path
          MAKENSIS="/c/Program Files (x86)/NSIS/makensis.exe"
          if [ ! -f "$MAKENSIS" ]; then
            echo "NSIS not found, installing via choco..."
            choco install nsis -y --no-progress
            MAKENSIS="/c/Program Files (x86)/NSIS/makensis.exe"
          fi

          # NSIS resolves paths relative to the .nsi file, so pass absolute path
          SOURCE_ABS="$(cygpath -w "$(pwd)/codex-windows-x64")"
          "$MAKENSIS" \
            -DAPP_VERSION="$app_ver" \
            -DSOURCE_DIR="$SOURCE_ABS" \
            $ICON_DEFINE \
            installer/windows/codex.nsi

          # NSIS writes OutFile relative to .nsi location, move to repo root
          mv installer/windows/Codex-Setup-*.exe .
          ls -lh Codex-Setup-*.exe

      - name: Upload Windows installer
        uses: actions/upload-artifact@v4
        with:
          name: Codex-Windows-x64
          path: Codex-Setup-*.exe
          retention-days: 30

      - name: Delete intermediate artifact
        if: always()
        uses: geekyeggo/delete-artifact@v5
        with:
          name: app-unpacked

      - name: Upload to GitHub Release (tag pushes only)
        if: startsWith(github.ref, 'refs/tags/v')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          tag="${GITHUB_REF#refs/tags/}"
          title="Codex Windows x64 ${tag}"
          notes="Windows x64 NSIS installer. App ${{ steps.versions.outputs.app }}, CLI ${{ steps.versions.outputs.cli }}."
          installer=$(ls Codex-Setup-*.exe)

          if gh release view "$tag" >/dev/null 2>&1; then
            gh release upload "$tag" "$installer" --clobber
          else
            gh release create "$tag" "$installer" --title "$title" --notes "$notes"
          fi
