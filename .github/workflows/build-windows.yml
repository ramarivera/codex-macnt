# Windows x64 Electron app build for Codex
#
# Uses a pre-compiled codex.exe from dist/windows-x64/ (cross-compiled locally
# via `mise run codex:win:compile`). This workflow only handles:
#   1. DMG/ASAR extraction (Linux runner — fast, ~2 min)
#   2. Native module rebuild + Electron packaging (Windows runner)
#
# No Rust compilation happens here — that's done locally and committed.

name: Build Codex Windows x64

on:
  workflow_dispatch:
  push:
    tags:
      - "v*"
    paths:
      - "dist/windows-x64/codex.exe"
      - ".github/workflows/build-windows.yml"

env:
  CODEX_DMG_URL: "https://persistent.oaistatic.com/codex-app-prod/Codex.dmg"

jobs:
  # Stage 1: Extract app resources from DMG (Linux — needs dmg2img + 7z)
  extract:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify codex.exe exists in repo
        run: |
          if [ ! -f dist/windows-x64/codex.exe ]; then
            echo "❌ dist/windows-x64/codex.exe not found in repo." >&2
            echo "   Run locally: mise run codex:win:compile" >&2
            echo "   Then commit and push dist/windows-x64/codex.exe" >&2
            exit 1
          fi
          file dist/windows-x64/codex.exe

      - name: Install extraction tools
        run: |
          sudo apt-get update
          sudo apt-get install -y p7zip-full dmg2img
          npm install -g @electron/asar

      - name: Download and extract DMG
        run: |
          curl -L --fail -o Codex.dmg "$CODEX_DMG_URL"
          dmg2img Codex.dmg Codex.img
          mkdir -p extracted
          7z x Codex.img -oextracted/ -y >/dev/null || true

      - name: Extract ASAR
        run: |
          ASAR_PATH=$(find extracted -name app.asar -type f | head -1)
          if [ -z "$ASAR_PATH" ]; then
            echo "Could not locate app.asar" >&2
            exit 1
          fi
          asar extract "$ASAR_PATH" app_unpacked/

      - name: Clean macOS-only files and install codex.exe from repo
        run: |
          cd app_unpacked
          rm -f native/sparkle.node
          rm -rf node_modules/electron-liquid-glass

          mkdir -p resources resources/bin
          cp "$GITHUB_WORKSPACE/dist/windows-x64/codex.exe" resources/codex.exe
          cp resources/codex.exe resources/bin/codex.exe

      - name: Upload extracted app bundle (internal, deleted after packaging)
        uses: actions/upload-artifact@v4
        with:
          name: app-unpacked
          path: app_unpacked/
          retention-days: 1

  # Stage 2: Native modules + packaging on Windows
  package:
    needs: extract
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Download extracted app bundle
        uses: actions/download-artifact@v4
        with:
          name: app-unpacked
          path: app_unpacked/

      - name: Determine Electron version
        id: electron-version
        shell: bash
        run: |
          cd app_unpacked
          ver=$(node -p "require('./package.json').devDependencies?.electron || ''" 2>/dev/null || true)
          ver="${ver#^}"
          if [ -z "$ver" ]; then
            echo "Could not determine Electron version from package.json" >&2
            exit 1
          fi
          echo "version=$ver" >> "$GITHUB_OUTPUT"

      - name: Rebuild native modules for Windows Electron
        shell: bash
        run: |
          electron_ver="${{ steps.electron-version.outputs.version }}"

          # The ASAR-extracted node_modules only have macOS prebuilt binaries
          # and are missing source/deps needed for compilation (e.g.
          # better-sqlite3/deps/common.gypi). Reinstall from npm to get full
          # source trees, then rebuild for Windows Electron ABI.

          # Get versions from the extracted bundle
          sqlite_ver=$(node -p "require('./app_unpacked/node_modules/better-sqlite3/package.json').version")
          pty_ver=$(node -p "require('./app_unpacked/node_modules/node-pty/package.json').version")
          echo "better-sqlite3=$sqlite_ver  node-pty=$pty_ver  electron=$electron_ver"

          # Install fresh copies with full source (--ignore-scripts skips native build)
          mkdir -p _native_src
          cd _native_src
          npm init -y
          npm install "better-sqlite3@$sqlite_ver" "node-pty@$pty_ver" --ignore-scripts
          cd ..

          # Replace extracted modules with fresh source trees
          rm -rf app_unpacked/node_modules/better-sqlite3
          rm -rf app_unpacked/node_modules/node-pty
          cp -r _native_src/node_modules/better-sqlite3 app_unpacked/node_modules/
          cp -r _native_src/node_modules/node-pty app_unpacked/node_modules/
          rm -rf _native_src

          # Install @electron/rebuild globally (can't npm install inside
          # app_unpacked — its package.json has workspace:* references)
          npm install -g @electron/rebuild

          # Rebuild against Windows Electron ABI
          electron-rebuild \
            --version "$electron_ver" \
            --arch x64 \
            --module-dir ./app_unpacked \
            --only better-sqlite3,node-pty \
            --build-from-source

          # Debug: show what was built
          echo "=== better-sqlite3 ==="
          find app_unpacked/node_modules/better-sqlite3/build -name "*.node" 2>/dev/null || echo "no .node files found"
          echo "=== node-pty ==="
          find app_unpacked/node_modules/node-pty/build -name "*.node" -o -name "*.dll" -o -name "*.exe" 2>/dev/null || echo "no .node files found"

      - name: Download and assemble Electron distribution
        shell: bash
        run: |
          electron_ver="${{ steps.electron-version.outputs.version }}"
          echo "Downloading Electron v${electron_ver} win32-x64..."
          curl -sL --fail -o electron.zip \
            "https://github.com/electron/electron/releases/download/v${electron_ver}/electron-v${electron_ver}-win32-x64.zip"

          mkdir -p electron-dist
          unzip -q electron.zip -d electron-dist

          # Replace default app with our extracted app bundle
          rm -f electron-dist/resources/default_app.asar
          mv app_unpacked electron-dist/resources/app

          # Rename electron.exe to Codex.exe
          mv electron-dist/electron.exe electron-dist/Codex.exe

          echo "=== Electron distribution assembled ==="
          ls -lh electron-dist/Codex.exe
          ls electron-dist/resources/app/package.json

      - name: Verify native modules are PE binaries
        shell: bash
        run: |
          APP=electron-dist/resources/app

          echo "=== Checking better-sqlite3 ==="
          sqlite_node=$(find "$APP/node_modules/better-sqlite3" -name "better_sqlite3.node" | head -1)
          if [ -z "$sqlite_node" ]; then
            echo "better_sqlite3.node not found" >&2
            exit 1
          fi
          file "$sqlite_node" | grep -i "PE32"

          echo "=== Checking node-pty ==="
          pty_node=$(find "$APP/node_modules/node-pty" -name "pty.node" | head -1)
          if [ -z "$pty_node" ]; then
            echo "pty.node not found" >&2
            exit 1
          fi
          file "$pty_node" | grep -i "PE32"

          echo "=== Checking Codex.exe (Electron) ==="
          file electron-dist/Codex.exe | grep -i "PE32"

          echo "=== Checking codex CLI ==="
          file "$APP/resources/codex.exe" | grep -i "PE32"

      - name: Get version info
        id: versions
        shell: bash
        run: |
          APP=electron-dist/resources/app
          cli_ver=$("$APP/resources/codex.exe" --version 2>/dev/null | awk '{print $2}' || echo "unknown")
          app_ver=$(node -p "require('./$APP/package.json').version" 2>/dev/null || echo "unknown")
          echo "cli=$cli_ver" >> "$GITHUB_OUTPUT"
          echo "app=$app_ver" >> "$GITHUB_OUTPUT"

      - name: Build NSIS installer
        shell: bash
        run: |
          app_ver="${{ steps.versions.outputs.app }}"
          mv electron-dist codex-windows-x64

          # NSIS is pre-installed on windows-latest at this path
          MAKENSIS="/c/Program Files (x86)/NSIS/makensis.exe"
          if [ ! -f "$MAKENSIS" ]; then
            echo "NSIS not found, installing via choco..."
            choco install nsis -y --no-progress
            MAKENSIS="/c/Program Files (x86)/NSIS/makensis.exe"
          fi

          # NSIS resolves paths relative to the .nsi file, so pass absolute path
          SOURCE_ABS="$(cygpath -w "$(pwd)/codex-windows-x64")"
          "$MAKENSIS" \
            -DAPP_VERSION="$app_ver" \
            -DSOURCE_DIR="$SOURCE_ABS" \
            installer/windows/codex.nsi

          # NSIS writes OutFile relative to .nsi location, move to repo root
          mv installer/windows/Codex-Setup-*.exe .
          ls -lh Codex-Setup-*.exe

      - name: Upload Windows installer
        uses: actions/upload-artifact@v4
        with:
          name: Codex-Windows-x64
          path: Codex-Setup-*.exe
          retention-days: 30

      - name: Delete intermediate artifact
        if: always()
        uses: geekyeggo/delete-artifact@v5
        with:
          name: app-unpacked

      - name: Upload to GitHub Release (tag pushes only)
        if: startsWith(github.ref, 'refs/tags/v')
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          tag="${GITHUB_REF#refs/tags/}"
          title="Codex Windows x64 ${tag}"
          notes="Windows x64 NSIS installer. App ${{ steps.versions.outputs.app }}, CLI ${{ steps.versions.outputs.cli }}."
          installer=$(ls Codex-Setup-*.exe)

          if gh release view "$tag" >/dev/null 2>&1; then
            gh release upload "$tag" "$installer" --clobber
          else
            gh release create "$tag" "$installer" --title "$title" --notes "$notes"
          fi
